---
phase: 02-authentication-and-user-model
plan: 06
type: execute
depends_on: ["02-01", "02-02", "02-05"]
files_modified: [lib/contexts/AuthContext.tsx, components/ProtectedRoute.tsx, app/page.tsx, app/balances/page.tsx, app/settings/page.tsx]
---

<objective>
Setup authentication context and protected routes.

Purpose: Provide React context for accessing current user and profile across the app. Implement route protection to redirect unauthenticated users to login. Update existing pages (home, balances, settings) to require authentication.
Output: AuthContext provider with user/profile state, ProtectedRoute wrapper component, and protected main app pages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-setup/01-04-SUMMARY.md
@.planning/phases/02-authentication-and-user-model/02-01-SUMMARY.md
@.planning/phases/02-authentication-and-user-model/02-02-SUMMARY.md
@.planning/phases/02-authentication-and-user-model/02-05-SUMMARY.md

**Tech stack available:** React Context API, Supabase SSR, Next.js App Router
**Established patterns:** Client components for interactivity, server components for data fetching
**Key files:** lib/supabase/client.ts, lib/actions/user.ts, app/layout.tsx

**Constraining decisions:**
- Phase 1: Bottom nav navigation with Framer Motion transitions
- Phase 2 Plan 1: Magic link auth with middleware token refresh
- Phase 2 Plan 2: User profiles with display_name, currency_preference
- Phase 2 Plan 5: Auto-claim on login
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuthContext for client-side auth state</name>
  <files>lib/contexts/AuthContext.tsx</files>
  <action>Create 'use client' React Context for auth state. Use createContext and useState.
Context shape: { user: User | null; profile: Profile | null; loading: boolean; signOut: () => Promise<void> }
Provider component:
1. Import createClient from '@/lib/supabase/client' and getCurrentUserProfile from '@/lib/actions/user'
2. On mount (useEffect), get current user from supabase.auth.getUser(), fetch profile if user exists, set loading to false
3. Subscribe to auth state changes with supabase.auth.onAuthStateChange - update user and profile when session changes
4. signOut function: call supabase.auth.signOut(), set user/profile to null
5. Provide { user, profile, loading, signOut } to children
Export useAuth hook: useContext(AuthContext) with proper error if used outside provider. Add JSDoc explaining this provides client-side auth state.</action>
  <verify>AuthContext.tsx exports AuthProvider and useAuth hook, handles auth state and subscriptions</verify>
  <done>AuthContext works, tracks user/profile, updates on auth changes, provides signOut function</done>
</task>

<task type="auto">
  <name>Task 2: Wrap app with AuthProvider in layout</name>
  <files>app/layout.tsx</files>
  <action>Update root layout.tsx to wrap children with AuthProvider. Import AuthProvider from '@/lib/contexts/AuthContext'. In the JSX, wrap the existing div containing {children} with <AuthProvider>. Keep existing BottomNav, service worker script, and all metadata. AuthProvider must wrap the content area but stay inside the body tag. This makes auth context available to all pages.</action>
  <verify>layout.tsx imports and uses AuthProvider, wraps main content area</verify>
  <done>Root layout provides auth context to entire app, existing functionality preserved</done>
</task>

<task type="auto">
  <name>Task 3: Create ProtectedRoute component</name>
  <files>components/ProtectedRoute.tsx</files>
  <action>Create 'use client' component for route protection. Import useAuth from '@/lib/contexts/AuthContext' and useRouter from 'next/navigation'.
Component logic:
1. Destructure { user, loading } from useAuth()
2. If loading, show loading spinner (centered, iOS-native style)
3. If !user and !loading, redirect to /auth/login using router.push
4. If user exists, render children
Export default ProtectedRoute component accepting { children: React.ReactNode }. Add JSDoc explaining this redirects unauthenticated users to login.</action>
  <verify>ProtectedRoute.tsx exports component that checks auth state, shows loading, redirects if unauthenticated</verify>
  <done>ProtectedRoute prevents access without auth, shows loading state, renders children when authenticated</done>
</task>

<task type="auto">
  <name>Task 4: Protect main app pages with ProtectedRoute</name>
  <files>app/page.tsx, app/balances/page.tsx, app/settings/page.tsx</files>
  <action>Update all three existing pages to require authentication. For each page:
1. Change to 'use client' directive (currently server components)
2. Import ProtectedRoute from '@/components/ProtectedRoute'
3. Import useAuth from '@/lib/contexts/AuthContext'
4. Wrap existing page content with <ProtectedRoute>
5. Update page content to show authenticated user info (e.g., "Welcome back, {profile?.display_name || user?.email}")
6. Keep existing layout structure, safe-area padding, and iOS styling from Phase 1
For settings page specifically, add a "Sign Out" button that calls auth.signOut() from useAuth hook and redirects to /auth/login.</action>
  <verify>All three pages import ProtectedRoute, wrap content, display user info when authenticated</verify>
  <done>Home, balances, and settings pages require auth, redirect to login if unauthenticated, show user-specific content</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without TypeScript errors
- [ ] AuthContext provides user, profile, loading, signOut
- [ ] ProtectedRoute redirects to /auth/login when unauthenticated
- [ ] Main pages (/, /balances, /settings) require auth
- [ ] Settings page has working Sign Out button
- [ ] No lint errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Auth context available throughout app
- Protected routes redirect unauthenticated users
- Phase 2 complete: Authentication and User Model fully functional
  </success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-and-user-model/02-06-SUMMARY.md`:

---
phase: 02-authentication-and-user-model
plan: 06
completed: [DATE]
subsystem: auth
requires: [02-01, 02-02, 02-05]
provides: [auth-context, protected-routes, authenticated-pages]
affects: []
tags: [auth, context, routing, protected-routes]
key-decisions:
  - "React Context API for client-side auth state (simpler than zustand for this use case)"
  - "ProtectedRoute wrapper component for route protection"
  - "Auth state subscription with onAuthStateChange keeps context in sync"
  - "Main pages converted to client components for auth context access"
  - "Sign out button in settings page"
key-files:
  - lib/contexts/AuthContext.tsx
  - components/ProtectedRoute.tsx
  - app/layout.tsx
  - app/page.tsx
  - app/balances/page.tsx
  - app/settings/page.tsx
tech-stack:
  added: []
  patterns: [react-context-auth, protected-routes, auth-subscriptions]
---

# Phase 2 Plan 6: Auth Context and Protected Routes Summary

**[One-liner]**

## Accomplishments

## Files Created/Modified

## Decisions Made

## Issues Encountered

## Next Phase Readiness

**Phase 2 complete - Authentication and User Model fully implemented.**

Ready for Phase 3 (Data Model & Offline Foundation):
- User authentication works with magic links
- User profiles and participants tracked in database
- Invite and claiming flows established
- Auth context provides user state throughout app
- Protected routes prevent unauthorized access

**Foundation for Phase 3:**
- Authenticated users can create expenses
- Participant model ready for expense splitting
- User profiles have currency preferences for multi-currency support
- Auth patterns established for RLS policies on expense data

## Next Step

Phase 2 complete. Ready to plan Phase 3 (Data Model & Offline Foundation) with `/gsd:plan-phase 3`
</output>
