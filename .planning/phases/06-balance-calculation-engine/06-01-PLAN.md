---
phase: 06-balance-calculation-engine
plan: 01
type: execute
depends_on: []
files_modified: [lib/balances/calculator.ts, lib/balances/types.ts, lib/db/stores.ts]
---

<objective>
Build core balance calculation engine that aggregates expenses and splits to determine global balances per person.

Purpose: Foundation for all balance-related features. Must accurately track who owes whom across all expenses regardless of tags.
Output: Balance calculation functions that return net balances between all participants (global view, not tag-specific).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work
@.planning/phases/04-core-expense-creation/04-01-SUMMARY.md
@.planning/phases/04-core-expense-creation/04-03-SUMMARY.md

# Key files
@lib/db/types.ts
@lib/db/stores.ts

**Tech stack available:** Next.js 15, TypeScript, Tailwind, Framer Motion, IndexedDB
**Established patterns:** React hooks for data operations, optimistic updates, offline-first
**Constraining decisions:**
- Offline-first architecture (calculations must work locally)
- Tags are organizational, balances are global per person (PROJECT.md decision)
- Hybrid account model (participants can be users or non-users)

**Database operations available:**
- getExpenses(filters?) - returns all expenses
- getExpenseParticipants(expense_id) - returns participants for expense
- getExpenseSplits(expense_id) - returns split details for expense
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create balance types and data structures</name>
  <files>lib/balances/types.ts</files>
  <action>
Create TypeScript types for balance calculations:

```typescript
export type PersonIdentifier = {
  user_id: string | null;
  participant_id: string | null;
  name: string;  // For display
};

export type BalanceEntry = {
  from: PersonIdentifier;
  to: PersonIdentifier;
  amount: number;
  currency: string;
};

export type BalanceResult = {
  balances: BalanceEntry[];
  total_expenses: number;
  currency: string;  // Primary currency for this result
};
```

Why separate from and to: Direct debts (A owes B $50). This is the non-simplified view that shows actual expense relationships.

Design note: PersonIdentifier handles hybrid account model - person can be identified by user_id OR participant_id. Name included for UI display.
  </action>
  <verify>TypeScript compiles without errors (npx tsc --noEmit)</verify>
  <done>Balance types exist with PersonIdentifier, BalanceEntry, BalanceResult. Types support hybrid account model (user_id OR participant_id).</done>
</task>

<task type="auto">
  <name>Task 2: Implement core balance calculation algorithm</name>
  <files>lib/balances/calculator.ts</files>
  <action>
Create calculateBalances function that processes all expenses:

Algorithm:
1. Fetch all non-deleted expenses using getExpenses()
2. For each expense:
   a. Get expense participants (who paid, who owes)
   b. Get expense splits (how much each person owes)
   c. Record debt: each split participant owes the payer their split amount
3. Aggregate all debts per person pair
4. Return BalanceEntry array showing who owes whom

Key edge cases to handle:
- Person paid and also owes on same expense (subtract their own split from what others owe them)
- Multiple expenses between same two people (aggregate all debts)
- Expenses in different currencies (for now, calculate per currency - multi-currency aggregation comes in plan 06-05)

Use ExpenseParticipant to identify payer (paid_by_user_id or paid_by_participant_id).
Use ExpenseSplit to determine amounts owed by each person.

DO NOT implement debt simplification yet (that's plan 06-02). This calculates direct balances only.

Return type: BalanceResult with array of BalanceEntry showing direct debts.
  </action>
  <verify>Function compiles. Manual test: Create test data with 2-3 expenses, verify balances sum correctly (total owed = total paid).</verify>
  <done>calculateBalances() function returns accurate direct balances for all person pairs. Handles multiple expenses, hybrid account model, and currency separation.</done>
</task>

<task type="auto">
  <name>Task 3: Create useBalances hook for React integration</name>
  <files>hooks/useBalances.ts</files>
  <action>
Create React hook that wraps balance calculation with loading states:

```typescript
export function useBalances() {
  const [balances, setBalances] = useState<BalanceResult | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadBalances() {
      const result = await calculateBalances();
      setBalances(result);
      setLoading(false);
    }
    loadBalances();
  }, []);

  return { balances, loading };
}
```

Pattern: Follow useParticipants pattern (from 04-02-SUMMARY.md) - loads data on mount, provides loading state.

Why useEffect dependency array is empty: Balance calculation is pure function of all expenses. In future plans, we'll add real-time updates when expenses change.
  </action>
  <verify>Hook compiles. Import in a test component, verify balances and loading states work.</verify>
  <done>useBalances hook provides balances and loading state. Follows established hook patterns from Phase 4.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npx tsc --noEmit)
- [ ] Balance types defined with PersonIdentifier, BalanceEntry, BalanceResult
- [ ] calculateBalances() returns accurate direct balances
- [ ] Balance totals are mathematically correct (sum of all owed = sum of all paid)
- [ ] useBalances hook provides balances and loading state
- [ ] Code handles hybrid account model (user_id OR participant_id)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Balance calculation accurately aggregates expenses and splits
- Foundation ready for debt simplification (plan 06-02)
- Foundation ready for multi-currency (plan 06-05)
</success_criteria>

<output>
After completion, create `.planning/phases/06-balance-calculation-engine/06-01-SUMMARY.md`
</output>
