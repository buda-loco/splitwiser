---
phase: 06-balance-calculation-engine
plan: 04
type: execute
depends_on: []
files_modified: [lib/currency/exchangeRates.ts, lib/currency/types.ts]
---

<objective>
Integrate free currency exchange rate API with local caching for multi-currency balance calculations.

Purpose: Users travel internationally and track expenses in multiple currencies. Need real-time exchange rates without API costs.
Output: Exchange rate fetching and caching system using free tier API.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key files
@lib/db/types.ts

**Research findings:**
Free currency exchange rate APIs:
- **exchangerate-api.com**: 1,500 requests/month free tier, good rates, simple API
- **ECB (European Central Bank)**: Free, daily updates, reliable but EUR-centric
- **fixer.io**: Free tier limited (100 requests/month), requires signup

**Recommended: exchangerate-api.com**
- Endpoint: `https://api.exchangerate-api.com/v4/latest/{BASE_CURRENCY}`
- Returns: All exchange rates relative to base currency
- No auth required for basic tier
- Daily rate limits: 1,500 requests/month = ~50/day
- Response format: `{ "base": "USD", "rates": { "EUR": 0.85, "GBP": 0.73, ... } }`

**Caching strategy:**
- Cache rates in IndexedDB
- Refresh daily (24h TTL)
- Fallback to cached rates if API fails
- Store rates per base currency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create currency types and cache schema</name>
  <files>lib/currency/types.ts</files>
  <action>
Create types for exchange rates:

```typescript
export type ExchangeRateCache = {
  base_currency: string;  // e.g., "USD"
  rates: Record<string, number>;  // { "EUR": 0.85, "GBP": 0.73, ... }
  fetched_at: string;  // ISO timestamp
  expires_at: string;  // ISO timestamp (fetched_at + 24h)
};

export type CurrencyCode = 'AUD' | 'USD' | 'EUR' | 'GBP';

export const SUPPORTED_CURRENCIES: CurrencyCode[] = ['AUD', 'USD', 'EUR', 'GBP'];
```

Add to IndexedDB schema in lib/db/indexeddb.ts:
- Add STORES.EXCHANGE_RATES = 'exchange_rates'
- Store structure: { base_currency (key), rates, fetched_at, expires_at }
- Index on expires_at for cache cleanup
  </action>
  <verify>Types compile. IndexedDB schema updated with exchange_rates store.</verify>
  <done>Currency types defined. Exchange rate cache schema added to IndexedDB.</done>
</task>

<task type="auto">
  <name>Task 2: Implement exchange rate fetching with caching</name>
  <files>lib/currency/exchangeRates.ts</files>
  <action>
Create exchange rate fetching function:

```typescript
export async function getExchangeRate(
  from: CurrencyCode,
  to: CurrencyCode
): Promise<number> {
  if (from === to) return 1.0;

  // Try cache first
  const cached = await getCachedRate(from);
  if (cached && !isExpired(cached)) {
    return cached.rates[to] || 1.0;
  }

  // Fetch fresh rates
  try {
    const response = await fetch(
      `https://api.exchangerate-api.com/v4/latest/${from}`
    );
    const data = await response.json();

    // Cache for 24 hours
    const now = new Date();
    const expires = new Date(now.getTime() + 24 * 60 * 60 * 1000);

    const cache: ExchangeRateCache = {
      base_currency: from,
      rates: data.rates,
      fetched_at: now.toISOString(),
      expires_at: expires.toISOString(),
    };

    await saveCachedRate(cache);

    return data.rates[to] || 1.0;
  } catch (error) {
    console.error('Failed to fetch exchange rates:', error);

    // Fallback to expired cache if available
    if (cached) {
      console.warn('Using expired exchange rate cache');
      return cached.rates[to] || 1.0;
    }

    // Ultimate fallback: return 1.0 (no conversion)
    console.warn('No exchange rate available, using 1:1');
    return 1.0;
  }
}

async function getCachedRate(base: string): Promise<ExchangeRateCache | null> {
  const db = await getDatabase();
  const tx = db.transaction([STORES.EXCHANGE_RATES], 'readonly');
  const store = tx.objectStore(STORES.EXCHANGE_RATES);
  const request = store.get(base);
  return promisifyRequest(request);
}

async function saveCachedRate(cache: ExchangeRateCache): Promise<void> {
  const db = await getDatabase();
  const tx = db.transaction([STORES.EXCHANGE_RATES], 'readwrite');
  const store = tx.objectStore(STORES.EXCHANGE_RATES);
  await promisifyRequest(store.put(cache));
}

function isExpired(cache: ExchangeRateCache): boolean {
  return new Date(cache.expires_at) < new Date();
}
```

Error handling:
- Network failure → use cached rate (even if expired)
- No cache → return 1.0 (no conversion)
- Invalid currency → return 1.0

Why 24h TTL: Exchange rates don't change significantly intraday for personal expense tracking. Daily refresh is sufficient and respects API limits.

DO NOT use environment variables or API keys. This endpoint is public and free.
  </action>
  <verify>Function compiles. Test with fetch to exchangerate-api.com, verify caching works, verify fallback to expired cache on network error.</verify>
  <done>getExchangeRate() fetches rates from API, caches in IndexedDB with 24h TTL, falls back to cache on error.</done>
</task>

<task type="auto">
  <name>Task 3: Create currency conversion utility</name>
  <files>lib/currency/exchangeRates.ts</files>
  <action>
Add convenience function for amount conversion:

```typescript
export async function convertAmount(
  amount: number,
  from: CurrencyCode,
  to: CurrencyCode
): Promise<number> {
  const rate = await getExchangeRate(from, to);
  return parseFloat((amount * rate).toFixed(2));
}

export async function convertBalances(
  balances: BalanceEntry[],
  targetCurrency: CurrencyCode
): Promise<BalanceEntry[]> {
  const converted: BalanceEntry[] = [];

  for (const balance of balances) {
    const convertedAmount = await convertAmount(
      balance.amount,
      balance.currency as CurrencyCode,
      targetCurrency
    );

    converted.push({
      ...balance,
      amount: convertedAmount,
      currency: targetCurrency,
    });
  }

  return converted;
}
```

Why toFixed(2): Money amounts displayed to 2 decimal places. Prevents floating point precision issues.

convertBalances: Batch convert all balance entries to target currency. Used in plan 06-05 for multi-currency balance view.
  </action>
  <verify>Functions compile. Test convertAmount with different currencies. Verify rounding to 2 decimals.</verify>
  <done>convertAmount() and convertBalances() utility functions handle currency conversion with proper rounding.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npx tsc --noEmit)
- [ ] Exchange rate API integration works
- [ ] Rates cached in IndexedDB with 24h TTL
- [ ] Cache fallback works on network error
- [ ] Currency conversion functions work correctly
- [ ] Amounts rounded to 2 decimal places
- [ ] No API keys required (using free public endpoint)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Exchange rate fetching and caching functional
- Graceful degradation (cache fallback, 1:1 fallback)
- Foundation ready for multi-currency balance view (plan 06-05)
- Foundation ready for manual rate override (plan 06-06)
</success_criteria>

<output>
After completion, create `.planning/phases/06-balance-calculation-engine/06-04-SUMMARY.md`
</output>
