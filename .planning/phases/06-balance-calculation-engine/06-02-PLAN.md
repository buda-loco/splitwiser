---
phase: 06-balance-calculation-engine
plan: 02
type: execute
depends_on: ["06-01"]
files_modified: [lib/balances/simplification.ts, lib/balances/calculator.ts]
---

<objective>
Implement debt simplification algorithm that minimizes the number of transactions needed to settle all debts.

Purpose: Users want fewer transactions. If A owes B $50 and B owes C $50, simpler to have A pay C $50 directly (1 transaction vs 2).
Output: Debt simplification function that reduces direct balances to minimum transaction count.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work in this phase
@.planning/phases/06-balance-calculation-engine/06-01-SUMMARY.md

# Key files
@lib/balances/types.ts
@lib/balances/calculator.ts

**Constraining decisions:**
- Debt simplification is OPTIONAL toggle (PROJECT.md: "optional toggle" in Settlement section)
- Users should be able to choose between simplified and direct views
- Direct view shows actual expense relationships, simplified view shows minimum transactions

**Research findings:**
Debt simplification is a graph algorithm problem:
- **Greedy algorithm**: Repeatedly settle largest debt with largest credit. Simple but not always optimal.
- **Optimal algorithm**: Minimum number of transactions (NP-complete). For small groups (<20 people), acceptable.
- **Practical approach**: Use greedy for >10 people, optimal for ≤10 people.

Algorithm for optimal simplification (≤10 people):
1. Calculate net balance per person (sum what they owe minus sum what they're owed)
2. Split into creditors (positive balance) and debtors (negative balance)
3. Match debtors to creditors greedily (largest debtor to largest creditor)
4. Each match becomes one transaction
5. Continue until all balances zero

This produces minimum transactions for small groups while being computationally efficient.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement debt simplification algorithm</name>
  <files>lib/balances/simplification.ts</files>
  <action>
Create simplifyDebts function:

```typescript
import type { BalanceEntry, PersonIdentifier } from './types';

export function simplifyDebts(balances: BalanceEntry[]): BalanceEntry[] {
  // Step 1: Calculate net balance per person
  // Net = (total owed TO them) - (total they OWE)
  const netBalances = new Map<string, { person: PersonIdentifier, amount: number }>();

  for (const entry of balances) {
    // entry.from owes entry.to entry.amount
    const fromKey = entry.from.user_id || entry.from.participant_id;
    const toKey = entry.to.user_id || entry.to.participant_id;

    // Update from's balance (they owe more)
    const fromBalance = netBalances.get(fromKey) || { person: entry.from, amount: 0 };
    fromBalance.amount -= entry.amount;
    netBalances.set(fromKey, fromBalance);

    // Update to's balance (they're owed more)
    const toBalance = netBalances.get(toKey) || { person: entry.to, amount: 0 };
    toBalance.amount += entry.amount;
    netBalances.set(toKey, toBalance);
  }

  // Step 2: Split into creditors and debtors
  const creditors: { person: PersonIdentifier, amount: number }[] = [];
  const debtors: { person: PersonIdentifier, amount: number }[] = [];

  for (const [_, balance] of netBalances) {
    if (balance.amount > 0.01) {  // Creditor (owed money), use 0.01 to handle floating point
      creditors.push(balance);
    } else if (balance.amount < -0.01) {  // Debtor (owes money)
      debtors.push({ ...balance, amount: -balance.amount });  // Make amount positive for easier math
    }
    // Ignore balances within 0.01 of zero (rounding errors)
  }

  // Step 3: Sort by amount (largest first) for greedy matching
  creditors.sort((a, b) => b.amount - a.amount);
  debtors.sort((a, b) => b.amount - a.amount);

  // Step 4: Match debtors to creditors
  const simplified: BalanceEntry[] = [];
  let creditorIndex = 0;
  let debtorIndex = 0;

  while (creditorIndex < creditors.length && debtorIndex < debtors.length) {
    const creditor = creditors[creditorIndex];
    const debtor = debtors[debtorIndex];

    const settleAmount = Math.min(creditor.amount, debtor.amount);

    simplified.push({
      from: debtor.person,
      to: creditor.person,
      amount: parseFloat(settleAmount.toFixed(2)),  // Round to 2 decimals
      currency: balances[0].currency,  // Assume all same currency for now
    });

    creditor.amount -= settleAmount;
    debtor.amount -= settleAmount;

    if (creditor.amount < 0.01) creditorIndex++;
    if (debtor.amount < 0.01) debtorIndex++;
  }

  return simplified;
}
```

Why greedy is acceptable: For typical friend groups (3-10 people), greedy produces near-optimal results. The difference between greedy and optimal is usually 0-1 transactions.

Key property: Total money owed stays the same. Only the transaction paths change.
  </action>
  <verify>Function compiles. Test with sample data: 3 people (A owes B $50, B owes C $50) should simplify to A owes C $50 (2 transactions → 1).</verify>
  <done>simplifyDebts() function reduces direct balances to minimum transactions. Handles net balance calculation, creditor/debtor split, and greedy matching.</done>
</task>

<task type="auto">
  <name>Task 2: Add simplified option to balance calculator</name>
  <files>lib/balances/calculator.ts</files>
  <action>
Update calculateBalances to support simplification option:

```typescript
export async function calculateBalances(options?: {
  simplified?: boolean;
}): Promise<BalanceResult> {
  // ... existing calculation logic ...

  const directBalances = /* existing direct balance calculation */;

  const balances = options?.simplified
    ? simplifyDebts(directBalances)
    : directBalances;

  return {
    balances,
    total_expenses: /* existing */,
    currency: /* existing */,
  };
}
```

Pattern: Optional parameter with default to false (direct balances). User explicitly opts into simplification.

Why default to direct: Shows actual expense relationships. Simplification is optimization, not requirement.
  </action>
  <verify>Function compiles. Test both modes: simplified=false returns direct balances, simplified=true returns simplified balances.</verify>
  <done>calculateBalances() supports simplified option. Returns direct balances by default, simplified when requested.</done>
</task>

<task type="auto">
  <name>Task 3: Update useBalances hook with simplification toggle</name>
  <files>hooks/useBalances.ts</files>
  <action>
Add simplified state to useBalances hook:

```typescript
export function useBalances() {
  const [balances, setBalances] = useState<BalanceResult | null>(null);
  const [loading, setLoading] = useState(true);
  const [simplified, setSimplified] = useState(false);

  useEffect(() => {
    async function loadBalances() {
      const result = await calculateBalances({ simplified });
      setBalances(result);
      setLoading(false);
    }

    setLoading(true);
    loadBalances();
  }, [simplified]);  // Recalculate when simplified toggle changes

  return {
    balances,
    loading,
    simplified,
    setSimplified,
  };
}
```

Pattern: Similar to filter state in useParticipants. State change triggers recalculation.

Return both simplified state and setter so UI can toggle between views.
  </action>
  <verify>Hook compiles. Toggling simplified state triggers recalculation with new mode.</verify>
  <done>useBalances hook supports simplified toggle. Exposes setSimplified for UI control.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npx tsc --noEmit)
- [ ] simplifyDebts() reduces transaction count
- [ ] Simplified balances maintain same total amounts (money conserved)
- [ ] calculateBalances() supports simplified option
- [ ] useBalances hook provides simplified toggle
- [ ] Direct and simplified modes both work correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Debt simplification algorithm works correctly
- Toggle between direct and simplified balances functional
- Foundation ready for balance view UI (plan 06-03)
</success_criteria>

<output>
After completion, create `.planning/phases/06-balance-calculation-engine/06-02-SUMMARY.md`
</output>
