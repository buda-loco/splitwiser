---
phase: 06-balance-calculation-engine
plan: 06
type: execute
depends_on: []
files_modified: [lib/db/types.ts, lib/db/stores.ts, components/ExpenseForm.tsx]
---

<objective>
Add manual exchange rate override capability per expense for users who want to use specific rates (e.g., credit card rate, airport exchange).

Purpose: Auto exchange rates are approximations. Users may prefer actual rate they received (credit card, cash exchange).
Output: Optional manual_exchange_rate field on expenses with UI to set it.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key files
@lib/db/types.ts
@lib/db/stores.ts
@components/ExpenseForm.tsx
@lib/currency/exchangeRates.ts

**Established patterns:**
- Optional fields in types (category, tags from existing schema)
- Conditional UI in forms (ExpenseForm has conditional rendering)
- IndexedDB schema updates via migration pattern

**Use case examples:**
- User pays €100 at restaurant, credit card charged AU$165 (rate 1.65, not market 1.60)
- User exchanges cash at airport at unfavorable rate, wants to track actual loss
- User wants to lock in historical rate for old expense (not current market rate)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manual_exchange_rate to expense schema</name>
  <files>lib/db/types.ts, lib/db/indexeddb.ts</files>
  <action>
Update OfflineExpense type:

```typescript
export type OfflineExpense = {
  // ... existing fields ...
  manual_exchange_rate?: {
    from_currency: string;  // e.g., "EUR"
    to_currency: string;    // e.g., "AUD"
    rate: number;           // e.g., 1.65
  } | null;
};
```

Why optional: Most expenses use auto exchange rates. Manual override is exception.

Why object structure: Need to know which currencies the rate applies to. Rate of "1.65" is meaningless without knowing EUR→AUD.

Add to database schema migration comment: This field is nullable in database, optional in TypeScript. No schema migration needed if using flexible NoSQL-style columns in existing schema.

Note: If using strict SQL schema, this would be a new nullable column. Since we're using IndexedDB (schema-less), just adding to type is sufficient.
  </action>
  <verify>Type compiles. OfflineExpense has manual_exchange_rate optional field.</verify>
  <done>manual_exchange_rate field added to OfflineExpense type. Stores custom rate with from/to currencies.</done>
</task>

<task type="auto">
  <name>Task 2: Add manual rate input to ExpenseForm</name>
  <files>components/ExpenseForm.tsx</files>
  <action>
Add manual exchange rate section to form:

Location: After currency selector, before description field.

Conditional display:
- Only show if user's default currency differs from expense currency
- Example: If user preference is AUD and expense currency is EUR, show manual rate input
- Collapsed by default with "Set custom exchange rate" toggle/link

UI when expanded:
```jsx
<div className="space-y-2">
  <label>Exchange Rate (optional)</label>
  <div className="text-sm text-gray-600">
    1 {expenseCurrency} = ? {userDefaultCurrency}
  </div>
  <input
    type="number"
    step="0.0001"
    placeholder="e.g., 1.6500"
    value={manualRate || ''}
    onChange={(e) => setManualRate(e.target.value)}
    className="..."
  />
  <p className="text-xs text-gray-500">
    Leave empty to use current market rate
  </p>
</div>
```

Validation:
- Must be > 0 if provided
- Max 4 decimal places (standard for exchange rates)

On submit:
- If manualRate provided, set manual_exchange_rate on expense
- If empty, leave manual_exchange_rate null (use auto rate)

Why 4 decimals: Standard precision for exchange rates (e.g., 1 JPY = 0.0095 AUD).
  </action>
  <verify>Form compiles. Manual rate input appears when expense currency differs from user default. Rate saved with expense.</verify>
  <done>ExpenseForm includes optional manual exchange rate input. Conditionally shown, properly validated, saved with expense.</done>
</task>

<task type="auto">
  <name>Task 3: Use manual rate in currency conversion</name>
  <files>lib/currency/exchangeRates.ts</files>
  <action>
Update getExchangeRate to accept manual rate override:

```typescript
export async function getExchangeRate(
  from: CurrencyCode,
  to: CurrencyCode,
  manualRate?: { from_currency: string; to_currency: string; rate: number }
): Promise<number> {
  if (from === to) return 1.0;

  // Use manual rate if provided and matches conversion direction
  if (manualRate) {
    if (manualRate.from_currency === from && manualRate.to_currency === to) {
      return manualRate.rate;
    }
    if (manualRate.from_currency === to && manualRate.to_currency === from) {
      return 1 / manualRate.rate;  // Inverse rate
    }
  }

  // Fall back to API rate (existing logic)
  // ... existing implementation ...
}
```

Update convertBalances:
```typescript
export async function convertBalances(
  balances: BalanceEntry[],
  targetCurrency: CurrencyCode,
  expenses?: OfflineExpense[]  // Optional: to get manual rates
): Promise<BalanceEntry[]> {
  // For each balance, check if original expense has manual rate
  // If so, use it. Otherwise use API rate.
  // ... implementation ...
}
```

Why inverse rate: If user sets EUR→AUD as 1.65, and we need AUD→EUR, use 1/1.65 = 0.606.

Pattern: Manual rate takes precedence over API rate. If manual rate doesn't match needed conversion, fall back to API.
  </action>
  <verify>Function compiles. Manual rate used when provided and matches conversion. Falls back to API rate otherwise.</verify>
  <done>getExchangeRate() uses manual rate when available. Handles forward and inverse conversions. Falls back to API rate.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npx tsc --noEmit)
- [ ] manual_exchange_rate field in OfflineExpense type
- [ ] ExpenseForm shows manual rate input conditionally
- [ ] Manual rate saved with expense
- [ ] Currency conversion uses manual rate when available
- [ ] Inverse rate calculation correct (1/rate)
- [ ] Fallback to API rate works
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Manual exchange rate override functional
- UI intuitive and conditional
- Currency conversion respects manual rates
- Graceful fallback to API rates
</success_criteria>

<output>
After completion, create `.planning/phases/06-balance-calculation-engine/06-06-SUMMARY.md`
</output>
