---
phase: 03-data-model-and-offline-foundation
plan: 04
type: execute
depends_on: ["03-03"]
files_modified: [lib/offline/queue.ts, lib/offline/operations.ts]
---

<objective>
Setup offline operation queue that tracks all mutations for later sync to Supabase.

Purpose: Create the queuing system that records all create/update/delete operations performed offline, enabling automatic sync when connectivity returns. Provides the foundation for optimistic updates and conflict resolution.
Output: Operation queue manager with typed operation definitions and queue processing logic.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-03-SUMMARY.md
@lib/db/indexeddb.ts
@lib/db/stores.ts
@lib/db/types.ts

**Tech stack available:**
- IndexedDB with sync_queue store
- TypeScript with strict mode
- Existing CRUD operations in lib/db/stores.ts

**Established patterns:**
- Promise-based API for async operations
- Type definitions in lib/db/types.ts
- Utility modules in lib/ subdirectories

**Offline-first requirement:**
- All mutations must be queued
- Queue persists across sessions (IndexedDB)
- Operations replay in order during sync
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create operation type definitions and queue manager</name>
  <files>lib/offline/operations.ts</files>
  <action>Define typed operation structures for all mutation types and create operation builder functions.

**Create operation types:**

```typescript
// Base operation interface
export type Operation = {
  id: string; // UUID for the operation itself
  timestamp: string; // When operation was queued
  table: 'expenses' | 'expense_participants' | 'expense_splits' | 'expense_tags' | 'settlements';
  operation_type: 'create' | 'update' | 'delete';
  record_id: string; // UUID of the record being modified
  status: 'pending' | 'synced' | 'failed' | 'conflict';
  retry_count: number;
  error_message?: string;
  conflict_resolution?: 'local_wins' | 'remote_wins' | 'manual';
};

// Specific operation types with payloads
export type CreateExpenseOperation = Operation & {
  operation_type: 'create';
  table: 'expenses';
  payload: Omit<OfflineExpense, 'id' | 'created_at'>;
};

export type UpdateExpenseOperation = Operation & {
  operation_type: 'update';
  table: 'expenses';
  payload: Partial<OfflineExpense>;
  original_values: Partial<OfflineExpense>; // For conflict detection
};

export type DeleteExpenseOperation = Operation & {
  operation_type: 'delete';
  table: 'expenses';
  payload: { id: string };
};

// Similar types for other tables (participants, splits, tags, settlements)
```

**Create operation builder functions:**
- `createOperation(type: 'create', table: string, payload: any): Operation` - generates UUID, timestamp, wraps payload
- `updateOperation(type: 'update', table: string, record_id: string, payload: any, original: any): Operation`
- `deleteOperation(type: 'delete', table: string, record_id: string): Operation`

All builders generate crypto.randomUUID() for operation ID, use ISO timestamp, set status to 'pending', retry_count to 0.

**Avoid:**
- DO NOT implement sync execution here (Plan 05 handles that)
- DO NOT add network detection logic (Plan 06 handles that)
- DO NOT implement conflict resolution yet (Plan 05 handles that)</action>
  <verify>TypeScript compiles, operation types defined, builder functions return properly typed operations</verify>
  <done>Operation types defined for all tables and operation types, builder functions created with UUID generation and timestamps, no sync logic included</done>
</task>

<task type="auto">
  <name>Task 2: Implement queue management functions</name>
  <files>lib/offline/queue.ts</files>
  <action>Create queue manager that interfaces with IndexedDB sync_queue store and provides queue manipulation functions.

**Implement QueueManager class:**

```typescript
export class QueueManager {
  // Add operation to queue
  async enqueue(operation: Operation): Promise<void> {
    // Add to sync_queue store via addToSyncQueue from stores.ts
    // Operation becomes persistent immediately
  }

  // Get all pending operations in chronological order
  async getPending(): Promise<Operation[]> {
    // Query sync_queue store for status='pending'
    // Sort by timestamp ascending (FIFO)
    // Return array of operations
  }

  // Get operations for specific record
  async getOperationsForRecord(table: string, record_id: string): Promise<Operation[]> {
    // Query sync_queue for matching table and record_id
    // Used for conflict detection and operation coalescing
  }

  // Mark operation as synced
  async markSynced(operation_id: string): Promise<void> {
    // Update operation status to 'synced'
    // Operation remains in queue for audit trail
  }

  // Mark operation as failed with error message
  async markFailed(operation_id: string, error: string): Promise<void> {
    // Update status to 'failed'
    // Increment retry_count
    // Store error_message
  }

  // Mark operation as conflicted
  async markConflict(operation_id: string, resolution?: string): Promise<void> {
    // Update status to 'conflict'
    // Store conflict_resolution strategy if provided
  }

  // Remove operation from queue (after successful sync or manual intervention)
  async remove(operation_id: string): Promise<void> {
    // Delete from sync_queue store
    // Only for manual cleanup or after conflict resolution
  }

  // Get failed operations for retry
  async getFailedOperations(): Promise<Operation[]> {
    // Query for status='failed'
    // Return operations that need retry
  }

  // Get queue size for UI display
  async getQueueSize(): Promise<{ pending: number; failed: number; conflict: number }> {
    // Count operations by status
    // Return object with counts
  }

  // Clear synced operations (optional cleanup)
  async clearSynced(): Promise<void> {
    // Remove operations with status='synced'
    // Keep recent ones for audit (last 100?)
  }
}

export const queueManager = new QueueManager();
```

Use IndexedDB transactions for all operations. Handle errors gracefully with try/catch. All methods async, return Promises.

**Avoid:**
- DO NOT implement automatic sync triggering (Plan 05)
- DO NOT add retry logic with timers (Plan 05)
- DO NOT implement operation coalescing yet (optimization for later)</action>
  <verify>TypeScript compiles, QueueManager class with all methods defined, methods use IndexedDB via stores.ts functions</verify>
  <done>QueueManager implemented with enqueue, getPending, marking operations, removal, and queue statistics. All methods use IndexedDB transactions. No automatic sync logic.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/offline/operations.ts created with operation type definitions
- [ ] Operation builder functions implemented
- [ ] lib/offline/queue.ts created with QueueManager class
- [ ] All queue management methods implemented
- [ ] TypeScript compiles without errors
- [ ] No network calls or sync logic in queue layer
- [ ] Operations persist across sessions (IndexedDB)
</verification>

<success_criteria>
- Operation types defined for all mutation types
- Queue manager fully functional with persistence
- Operations can be enqueued, queried, and marked with status
- Queue survives page refresh and browser restart
- Foundation ready for sync engine implementation
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-offline-foundation/03-04-SUMMARY.md`:

# Phase 3 Plan 4: Offline Operation Queue Summary

**Persistent operation queue for tracking offline mutations**

## Accomplishments

- Defined typed operation structures for all mutation types
- Created operation builder functions with UUID generation
- Implemented QueueManager class with full queue manipulation
- Queue persists across sessions via IndexedDB
- Foundation ready for sync engine

## Files Created/Modified

- `lib/offline/operations.ts` - Operation type definitions and builders
- `lib/offline/queue.ts` - QueueManager class

## Decisions Made

[Document queue design decisions, operation structure choices]

## Issues Encountered

[IndexedDB transaction issues, TypeScript type challenges, or "None"]

## Next Step

Ready for 03-05-PLAN.md (Create sync engine with conflict resolution)
</output>
