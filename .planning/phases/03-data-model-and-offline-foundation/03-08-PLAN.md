---
phase: 03-data-model-and-offline-foundation
plan: 08
type: execute
depends_on: ["03-05", "03-06"]
files_modified: [lib/network/status.ts, hooks/useNetworkStatus.ts, components/SyncIndicator.tsx]
---

<objective>
Add connection status detection and sync indicators for user visibility into offline/online state and sync progress.

Purpose: Provide transparency about network state and sync status so users understand when they're working offline and when changes are syncing. Essential for trust in offline-first architecture.
Output: Network status detection, automatic sync on reconnect, and UI components showing sync state.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-05-SUMMARY.md
@.planning/phases/03-data-model-and-offline-foundation/03-06-SUMMARY.md
@lib/sync/engine.ts
@lib/offline/queue.ts
@hooks/useOptimisticMutation.ts

**Core value from PROJECT.md:**
"Beautiful iOS-native UX that makes expense splitting feel effortless."

**Tech stack available:**
- Navigator.onLine API for network detection
- React 19 with hooks
- Framer Motion for animations
- Tailwind CSS with iOS design tokens
- SyncEngine with status tracking

**Established patterns:**
- React hooks for state management
- Components in components/ directory
- iOS-native design patterns

**Transparency requirement:**
- Users must know when working offline
- Sync progress visible but non-intrusive
- Trust through visibility
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement network status detection with automatic sync</name>
  <files>lib/network/status.ts, hooks/useNetworkStatus.ts</files>
  <action>Create NetworkStatusManager that monitors connectivity and triggers sync when connection restored.

**In lib/network/status.ts:**

```typescript
import { syncEngine } from '@/lib/sync/engine';

export type NetworkStatus = {
  online: boolean;
  connection_type?: 'wifi' | 'cellular' | 'none' | 'unknown';
  effective_type?: '4g' | '3g' | '2g' | 'slow-2g' | 'unknown';
};

export class NetworkStatusManager {
  private status: NetworkStatus = {
    online: typeof navigator !== 'undefined' ? navigator.onLine : true,
    connection_type: 'unknown',
    effective_type: 'unknown'
  };

  private listeners: Set<(status: NetworkStatus) => void> = new Set();
  private syncOnReconnect = true;

  constructor() {
    if (typeof window !== 'undefined') {
      this.initListeners();
      this.detectConnectionType();
    }
  }

  // Initialize online/offline event listeners
  private initListeners(): void {
    window.addEventListener('online', () => {
      this.status.online = true;
      this.notifyListeners();

      // Auto-sync when connection restored
      if (this.syncOnReconnect) {
        this.triggerSync();
      }
    });

    window.addEventListener('offline', () => {
      this.status.online = false;
      this.notifyListeners();
    });

    // Listen to connection changes (if available)
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      connection.addEventListener('change', () => {
        this.detectConnectionType();
      });
    }
  }

  // Detect connection type using Network Information API
  private detectConnectionType(): void {
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;

      // connection.type: 'wifi', 'cellular', 'none', etc.
      this.status.connection_type = connection.type || 'unknown';

      // connection.effectiveType: '4g', '3g', '2g', 'slow-2g'
      this.status.effective_type = connection.effectiveType || 'unknown';

      this.notifyListeners();
    }
  }

  // Trigger sync manually or automatically
  private async triggerSync(): Promise<void> {
    try {
      await syncEngine.triggerSync();
    } catch (error) {
      console.error('Auto-sync failed:', error);
    }
  }

  // Subscribe to status changes
  subscribe(listener: (status: NetworkStatus) => void): () => void {
    this.listeners.add(listener);
    listener(this.status); // Call immediately with current status

    // Return unsubscribe function
    return () => {
      this.listeners.delete(listener);
    };
  }

  // Notify all listeners
  private notifyListeners(): void {
    for (const listener of this.listeners) {
      listener(this.status);
    }
  }

  // Get current status
  getStatus(): NetworkStatus {
    return { ...this.status };
  }

  // Enable/disable auto-sync on reconnect
  setAutoSync(enabled: boolean): void {
    this.syncOnReconnect = enabled;
  }
}

export const networkStatusManager = new NetworkStatusManager();
```

**In hooks/useNetworkStatus.ts:**

```typescript
'use client';

import { useEffect, useState } from 'react';
import { networkStatusManager, NetworkStatus } from '@/lib/network/status';

export function useNetworkStatus() {
  const [status, setStatus] = useState<NetworkStatus>(
    networkStatusManager.getStatus()
  );

  useEffect(() => {
    // Subscribe to network status changes
    const unsubscribe = networkStatusManager.subscribe(setStatus);

    return () => {
      unsubscribe();
    };
  }, []);

  return status;
}
```

**Avoid:**
- DO NOT poll navigator.onLine repeatedly (use events)
- DO NOT sync on every network change (only on offlineâ†’online transition)
- DO NOT fail if Network Information API unavailable (graceful degradation)</action>
  <verify>TypeScript compiles, NetworkStatusManager with event listeners, hook returns online status, auto-sync triggers on reconnect</verify>
  <done>NetworkStatusManager implemented with online/offline detection, connection type detection, automatic sync on reconnect, React hook for component integration</done>
</task>

<task type="auto">
  <name>Task 2: Create sync indicator UI component</name>
  <files>components/SyncIndicator.tsx</files>
  <action>Create iOS-native sync indicator component that shows network status and sync progress.

**Implement SyncIndicator component:**

```typescript
'use client';

import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useNetworkStatus } from '@/hooks/useNetworkStatus';
import { queueManager } from '@/lib/offline/queue';
import { syncEngine } from '@/lib/sync/engine';

export function SyncIndicator() {
  const { online } = useNetworkStatus();
  const [syncStatus, setSyncStatus] = useState<{
    pending: number;
    syncing: boolean;
  }>({
    pending: 0,
    syncing: false
  });

  // Update sync status periodically
  useEffect(() => {
    async function checkSyncStatus() {
      const { pending } = await queueManager.getQueueSize();
      const status = syncEngine.getStatus();

      setSyncStatus({
        pending,
        syncing: status.is_syncing
      });
    }

    checkSyncStatus();

    // Poll every 2 seconds when there are pending operations
    const interval = setInterval(checkSyncStatus, 2000);

    return () => {
      clearInterval(interval);
    };
  }, []);

  // Determine indicator state
  const getIndicatorState = () => {
    if (!online) {
      return { color: 'bg-yellow-500', text: 'Offline', icon: 'ðŸ“´' };
    } else if (syncStatus.syncing) {
      return { color: 'bg-blue-500', text: 'Syncing...', icon: 'ðŸ”„' };
    } else if (syncStatus.pending > 0) {
      return { color: 'bg-orange-500', text: `${syncStatus.pending} pending`, icon: 'â³' };
    } else {
      return { color: 'bg-green-500', text: 'Synced', icon: 'âœ“' };
    }
  };

  const indicator = getIndicatorState();

  // Only show when offline or syncing/pending
  const shouldShow = !online || syncStatus.syncing || syncStatus.pending > 0;

  return (
    <AnimatePresence>
      {shouldShow && (
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={{ duration: 0.2 }}
          className="fixed top-0 left-0 right-0 z-50 pointer-events-none"
        >
          <div className="max-w-md mx-auto px-4 pt-safe">
            <div
              className={`
                ${indicator.color}
                text-white text-sm font-medium
                px-4 py-2 rounded-full
                shadow-lg
                flex items-center justify-center gap-2
              `}
            >
              <span className="animate-spin-slow">{indicator.icon}</span>
              <span>{indicator.text}</span>
            </div>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

**Add to tailwind.config.ts if needed:**
```typescript
animation: {
  'spin-slow': 'spin 2s linear infinite',
}
```

**Component features:**
- Shows offline indicator when no connection
- Shows syncing indicator during sync
- Shows pending count when operations queued
- Auto-hides when fully synced and online
- Animates in/out smoothly with Framer Motion
- iOS-native pill design at top of screen
- Respects safe area for notched devices (pt-safe class)

**Avoid:**
- DO NOT make indicator intrusive (small, top, auto-hide)
- DO NOT block interactions (pointer-events-none)
- DO NOT show when everything is synced and online (visual noise)</action>
  <verify>TypeScript compiles, component renders with different states, animations work, shows/hides appropriately</verify>
  <done>SyncIndicator component created with offline/syncing/pending/synced states, Framer Motion animations, iOS-native design, auto-hide when synced</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/network/status.ts created with NetworkStatusManager
- [ ] hooks/useNetworkStatus.ts created with React hook
- [ ] components/SyncIndicator.tsx created with UI component
- [ ] Auto-sync triggers when going from offline to online
- [ ] Indicator shows appropriate state (offline/syncing/pending/synced)
- [ ] Animations smooth with Framer Motion
- [ ] TypeScript compiles without errors
- [ ] Component auto-hides when synced
</verification>

<success_criteria>
- Network status detection working with online/offline events
- Automatic sync triggers on reconnect
- Sync indicator visible at top of screen
- Shows appropriate state with visual feedback
- Non-intrusive design that auto-hides
- Users have transparency into sync state
- Phase 3 complete: offline-first foundation ready
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-offline-foundation/03-08-SUMMARY.md`:

# Phase 3 Plan 8: Connection Status and Sync Indicators Summary

**Network monitoring with automatic sync and user-visible sync state**

## Accomplishments

- Implemented NetworkStatusManager with online/offline detection
- Added connection type detection using Network Information API
- Created automatic sync trigger on reconnect
- Built SyncIndicator component with iOS-native design
- Added Framer Motion animations for smooth transitions
- Indicator shows offline/syncing/pending/synced states
- Auto-hides when fully synced for clean UI

## Files Created/Modified

- `lib/network/status.ts` - NetworkStatusManager implementation
- `hooks/useNetworkStatus.ts` - React hook for network status
- `components/SyncIndicator.tsx` - Sync indicator UI component

## Decisions Made

[Document auto-sync strategy, indicator placement choice, animation patterns]

## Issues Encountered

[Network API compatibility, animation issues, or "None"]

## Next Step

**Phase 3 Complete!** All 8 plans finished. Ready for Phase 4: Core Expense Creation

---

**Phase Summary:**
- âœ… Database schema with 6 core tables
- âœ… RLS policies securing all data
- âœ… IndexedDB offline storage layer
- âœ… Operation queue for pending mutations
- âœ… Sync engine with conflict resolution
- âœ… Optimistic updates for instant UI
- âœ… Realtime subscriptions for live updates
- âœ… Network status and sync indicators

**Foundation complete for offline-first expense tracking.**
</output>
