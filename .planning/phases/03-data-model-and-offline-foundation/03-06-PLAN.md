---
phase: 03-data-model-and-offline-foundation
plan: 06
type: execute
depends_on: ["03-03", "03-05"]
files_modified: [lib/offline/optimistic.ts, hooks/useOptimisticMutation.ts]
---

<objective>
Implement optimistic updates for immediate UI feedback when creating/editing expenses offline.

Purpose: Provide instant UI responsiveness by immediately reflecting changes in the UI before sync completes. Creates the "feels native" experience that's core to the product value.
Output: Optimistic update system with automatic rollback on failure and React hook for components.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-03-SUMMARY.md
@.planning/phases/03-data-model-and-offline-foundation/03-05-SUMMARY.md
@lib/db/stores.ts
@lib/offline/queue.ts
@lib/sync/engine.ts

**Core value from PROJECT.md:**
"Beautiful iOS-native UX that makes expense splitting feel effortless."

**Tech stack available:**
- React 19 with hooks
- IndexedDB for local state
- Sync engine with queue
- TypeScript

**Established patterns:**
- React hooks in root hooks/ directory (if exists) or co-located
- Promise-based async operations
- Type definitions in lib/db/types.ts

**Optimistic updates requirement:**
- UI updates immediately (no loading spinners for offline ops)
- Changes persist even if sync fails
- Rollback visible errors only
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create optimistic update manager</name>
  <files>lib/offline/optimistic.ts</files>
  <action>Implement OptimisticUpdateManager that coordinates immediate local updates with operation queueing.

**Create OptimisticUpdateManager class:**

```typescript
import { queueManager } from './queue';
import { createOperation, updateOperation, deleteOperation } from './operations';
import * as stores from '@/lib/db/stores';

export type OptimisticUpdate<T> = {
  id: string; // UUID for this optimistic update
  operation_id: string; // Links to queued operation
  rollback: () => Promise<void>; // Function to undo the change
  status: 'pending' | 'committed' | 'rolled_back';
  data: T; // The optimistic data
};

export class OptimisticUpdateManager {
  private updates = new Map<string, OptimisticUpdate<any>>();

  // Create expense optimistically
  async createExpense(expense: any): Promise<string> {
    // 1. Generate ID for the expense
    const expense_id = crypto.randomUUID();
    const expense_with_id = { ...expense, id: expense_id, sync_status: 'pending' };

    // 2. Add to IndexedDB immediately (optimistic)
    await stores.createExpense(expense_with_id);

    // 3. Queue operation for sync
    const operation = createOperation('create', 'expenses', expense_with_id);
    await queueManager.enqueue(operation);

    // 4. Track optimistic update with rollback function
    const update: OptimisticUpdate<any> = {
      id: crypto.randomUUID(),
      operation_id: operation.id,
      rollback: async () => {
        await stores.deleteExpense(expense_id);
      },
      status: 'pending',
      data: expense_with_id
    };
    this.updates.set(update.id, update);

    return expense_id;
  }

  // Update expense optimistically
  async updateExpense(id: string, updates: any): Promise<void> {
    // 1. Get original values for rollback
    const original = await stores.getExpense(id);
    if (!original) throw new Error('Expense not found');

    // 2. Apply update immediately (optimistic)
    await stores.updateExpense(id, { ...updates, sync_status: 'pending' });

    // 3. Queue operation for sync
    const operation = updateOperation('update', 'expenses', id, updates, original);
    await queueManager.enqueue(operation);

    // 4. Track optimistic update with rollback
    const update: OptimisticUpdate<any> = {
      id: crypto.randomUUID(),
      operation_id: operation.id,
      rollback: async () => {
        await stores.updateExpense(id, original);
      },
      status: 'pending',
      data: updates
    };
    this.updates.set(update.id, update);
  }

  // Delete expense optimistically (soft delete)
  async deleteExpense(id: string): Promise<void> {
    // 1. Get original for rollback
    const original = await stores.getExpense(id);
    if (!original) throw new Error('Expense not found');

    // 2. Soft delete immediately
    await stores.deleteExpense(id);

    // 3. Queue operation
    const operation = deleteOperation('delete', 'expenses', id);
    await queueManager.enqueue(operation);

    // 4. Track with rollback
    const update: OptimisticUpdate<any> = {
      id: crypto.randomUUID(),
      operation_id: operation.id,
      rollback: async () => {
        await stores.updateExpense(id, { is_deleted: false, deleted_at: null });
      },
      status: 'pending',
      data: { id }
    };
    this.updates.set(update.id, update);
  }

  // Commit optimistic update (after successful sync)
  async commit(operation_id: string): Promise<void> {
    const update = Array.from(this.updates.values())
      .find(u => u.operation_id === operation_id);

    if (update) {
      update.status = 'committed';
      // Update IndexedDB record to sync_status = 'synced'
    }
  }

  // Rollback optimistic update (on sync failure)
  async rollback(operation_id: string): Promise<void> {
    const update = Array.from(this.updates.values())
      .find(u => u.operation_id === operation_id);

    if (update && update.status === 'pending') {
      await update.rollback();
      update.status = 'rolled_back';
    }
  }

  // Get pending optimistic updates (for UI sync indicator)
  getPending(): OptimisticUpdate<any>[] {
    return Array.from(this.updates.values())
      .filter(u => u.status === 'pending');
  }
}

export const optimisticUpdateManager = new OptimisticUpdateManager();
```

**Avoid:**
- DO NOT rollback on every error (only critical failures, not network timeouts)
- DO NOT implement automatic retry logic (sync engine handles that)
- DO NOT add toast notifications here (UI layer handles that)</action>
  <verify>TypeScript compiles, OptimisticUpdateManager with create/update/delete methods, proper rollback functions, tracks pending updates</verify>
  <done>OptimisticUpdateManager implemented with immediate IndexedDB updates, operation queueing, rollback capability, status tracking for all mutation types</done>
</task>

<task type="auto">
  <name>Task 2: Create React hook for optimistic mutations</name>
  <files>hooks/useOptimisticMutation.ts</files>
  <action>Create React hook that wraps OptimisticUpdateManager for easy component integration.

**Implement useOptimisticMutation hook:**

```typescript
'use client';

import { useState, useCallback } from 'react';
import { optimisticUpdateManager } from '@/lib/offline/optimistic';

export type MutationState = {
  isLoading: boolean;
  error: Error | null;
  data: any | null;
};

export function useOptimisticMutation<T = any>() {
  const [state, setState] = useState<MutationState>({
    isLoading: false,
    error: null,
    data: null
  });

  // Create expense
  const createExpense = useCallback(async (expense: any) => {
    setState({ isLoading: true, error: null, data: null });

    try {
      const id = await optimisticUpdateManager.createExpense(expense);
      setState({ isLoading: false, error: null, data: { id } });
      return id;
    } catch (error: any) {
      setState({ isLoading: false, error, data: null });
      throw error;
    }
  }, []);

  // Update expense
  const updateExpense = useCallback(async (id: string, updates: any) => {
    setState({ isLoading: true, error: null, data: null });

    try {
      await optimisticUpdateManager.updateExpense(id, updates);
      setState({ isLoading: false, error: null, data: { id } });
    } catch (error: any) {
      setState({ isLoading: false, error, data: null });
      throw error;
    }
  }, []);

  // Delete expense
  const deleteExpense = useCallback(async (id: string) => {
    setState({ isLoading: true, error: null, data: null });

    try {
      await optimisticUpdateManager.deleteExpense(id);
      setState({ isLoading: false, error: null, data: { id } });
    } catch (error: any) {
      setState({ isLoading: false, error, data: null });
      throw error;
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setState({ isLoading: false, error: null, data: null });
  }, []);

  return {
    createExpense,
    updateExpense,
    deleteExpense,
    reset,
    ...state
  };
}
```

**Hook usage example:**
```typescript
function ExpenseForm() {
  const { createExpense, isLoading, error } = useOptimisticMutation();

  const handleSubmit = async (data) => {
    try {
      await createExpense(data);
      // UI updates immediately, no spinner needed
      // Expense appears in list instantly
    } catch (err) {
      // Show error toast
    }
  };

  // ...
}
```

**Avoid:**
- DO NOT make isLoading block the UI (optimistic = instant feedback)
- DO NOT add automatic error toasts in hook (component decides how to show errors)
- DO NOT implement data fetching here (separate hook for queries)</action>
  <verify>TypeScript compiles, hook exports createExpense/updateExpense/deleteExpense functions, returns state object with isLoading/error/data</verify>
  <done>useOptimisticMutation hook created with mutation functions, state management, error handling, ready for component integration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/offline/optimistic.ts created with OptimisticUpdateManager
- [ ] hooks/useOptimisticMutation.ts created with React hook
- [ ] Optimistic updates happen immediately in IndexedDB
- [ ] Operations queued for sync after optimistic update
- [ ] Rollback functions properly restore original state
- [ ] TypeScript compiles without errors
- [ ] Hook ready for component integration
</verification>

<success_criteria>
- Optimistic updates provide instant UI feedback
- Changes persist in IndexedDB immediately
- Operations queued for background sync
- Rollback capability for failed operations
- React hook ready for expense creation/editing
- No loading spinners needed for offline operations
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-offline-foundation/03-06-SUMMARY.md`:

# Phase 3 Plan 6: Optimistic Updates Summary

**Instant UI feedback with optimistic updates and rollback capability**

## Accomplishments

- Implemented OptimisticUpdateManager for coordinated local updates
- Created rollback capability for failed operations
- Built React hook for easy component integration
- Integrated with operation queue for background sync
- Enabled instant UI responsiveness for offline operations

## Files Created/Modified

- `lib/offline/optimistic.ts` - OptimisticUpdateManager implementation
- `hooks/useOptimisticMutation.ts` - React hook for mutations

## Decisions Made

[Document optimistic update strategy, rollback triggers, error handling approach]

## Issues Encountered

[Race conditions, TypeScript challenges, or "None"]

## Next Step

Ready for 03-07-PLAN.md (Setup Supabase realtime subscriptions for live updates)
</output>
