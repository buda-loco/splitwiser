---
phase: 03-data-model-and-offline-foundation
plan: 03
type: execute
depends_on: ["03-01"]
files_modified: [lib/db/indexeddb.ts, lib/db/stores.ts]
---

<objective>
Implement IndexedDB wrapper for local storage with typed stores for offline-first architecture.

Purpose: Create the local database layer that enables offline expense tracking. Provides typed CRUD operations for expenses, participants, tags, and settlements stored locally in the browser.
Output: IndexedDB wrapper with stores, typed interfaces, and utility functions for local data persistence.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-01-SUMMARY.md
@lib/db/types.ts
@supabase/migrations/20260206000001_create_core_schema.sql

**Tech stack available:**
- IndexedDB API (native browser support, all modern browsers)
- TypeScript for type safety
- Existing type definitions in lib/db/types.ts

**Established patterns:**
- Type definitions in lib/db/types.ts
- Utility functions in lib/ subdirectories

**Offline-first requirement:**
- Must work without internet connection
- Local storage is source of truth until sync
- Queue operations for later sync
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IndexedDB wrapper with database initialization</name>
  <files>lib/db/indexeddb.ts</files>
  <action>Create IndexedDB wrapper class that handles database initialization, versioning, and store creation.

**Implementation details:**

```typescript
// Database configuration
const DB_NAME = 'splitwiser-offline';
const DB_VERSION = 1;

// Store names matching our schema
export const STORES = {
  EXPENSES: 'expenses',
  EXPENSE_PARTICIPANTS: 'expense_participants',
  EXPENSE_SPLITS: 'expense_splits',
  EXPENSE_TAGS: 'expense_tags',
  SETTLEMENTS: 'settlements',
  EXPENSE_VERSIONS: 'expense_versions',
  SYNC_QUEUE: 'sync_queue', // For pending operations
} as const;
```

Create `initDatabase()` function that:
1. Opens IndexedDB connection with DB_NAME and DB_VERSION
2. In onupgradeneeded handler, creates object stores for each table
3. Defines appropriate indexes for efficient querying:
   - expenses: primary key 'id', indexes on 'expense_date', 'is_deleted', 'created_by_user_id'
   - expense_participants: primary key 'id', index on 'expense_id'
   - expense_splits: primary key 'id', index on 'expense_id'
   - expense_tags: primary key 'id', indexes on 'expense_id' and 'tag'
   - settlements: primary key 'id', indexes on 'from_user_id', 'to_user_id'
   - expense_versions: primary key 'id', index on 'expense_id'
   - sync_queue: primary key 'id', index on 'status' (pending/synced/failed)

Use Promises instead of callbacks for better async/await support. Wrap IDBRequest in Promise wrappers.

**Avoid:**
- DO NOT use localStorage (5MB limit, no structured querying, synchronous)
- DO NOT use WebSQL (deprecated)
- DO NOT create store for participants table (Phase 2 already handles this, will sync later)
- DO NOT use auto-increment keys (use UUIDs from crypto.randomUUID() for offline compatibility)</action>
  <verify>TypeScript compiles without errors, initDatabase() returns Promise that resolves to IDBDatabase</verify>
  <done>IndexedDB wrapper created with database init, all stores defined with appropriate indexes, Promise-based API</done>
</task>

<task type="auto">
  <name>Task 2: Create typed store interfaces and CRUD operations</name>
  <files>lib/db/stores.ts, lib/db/types.ts</files>
  <action>Create typed interfaces extending lib/db/types.ts for IndexedDB records and implement CRUD operations for each store.

**Add to lib/db/types.ts:**
```typescript
// Offline-specific types
export type OfflineExpense = Expense & {
  sync_status: 'pending' | 'synced' | 'conflict';
  local_updated_at: string; // For conflict detection
};

export type SyncQueueItem = {
  id: string;
  operation: 'create' | 'update' | 'delete';
  table: string;
  record_id: string;
  payload: any;
  status: 'pending' | 'synced' | 'failed';
  created_at: string;
  error_message?: string;
};
```

**In lib/db/stores.ts, create functions:**

1. **Expense operations:**
   - `createExpense(expense: Omit<OfflineExpense, 'id' | 'created_at'>): Promise<string>` - generates UUID, adds to store, returns ID
   - `getExpense(id: string): Promise<OfflineExpense | null>`
   - `getExpenses(filters?: { tag?: string, startDate?: Date, endDate?: Date }): Promise<OfflineExpense[]>`
   - `updateExpense(id: string, updates: Partial<OfflineExpense>): Promise<void>`
   - `deleteExpense(id: string): Promise<void>` - soft delete (is_deleted = true)

2. **Expense participants operations:**
   - `addParticipantToExpense(expense_id: string, user_id?: string, participant_id?: string): Promise<string>`
   - `getExpenseParticipants(expense_id: string): Promise<ExpenseParticipant[]>`
   - `removeParticipantFromExpense(expense_id: string, participant_id: string): Promise<void>`

3. **Expense splits operations:**
   - `createSplit(split: Omit<ExpenseSplit, 'id' | 'created_at'>): Promise<string>`
   - `getExpenseSplits(expense_id: string): Promise<ExpenseSplit[]>`
   - `updateSplit(id: string, updates: Partial<ExpenseSplit>): Promise<void>`

4. **Expense tags operations:**
   - `addTagToExpense(expense_id: string, tag: string): Promise<void>`
   - `getExpenseTags(expense_id: string): Promise<string[]>`
   - `removeTagFromExpense(expense_id: string, tag: string): Promise<void>`

5. **Settlement operations:**
   - `createSettlement(settlement: Omit<Settlement, 'id' | 'created_at'>): Promise<string>`
   - `getSettlements(user_id?: string): Promise<Settlement[]>`

6. **Sync queue operations:**
   - `addToSyncQueue(item: Omit<SyncQueueItem, 'id' | 'created_at'>): Promise<void>`
   - `getPendingSyncItems(): Promise<SyncQueueItem[]>`
   - `markSyncItemCompleted(id: string): Promise<void>`
   - `markSyncItemFailed(id: string, error: string): Promise<void>`

All operations use transactions. Use 'readwrite' for mutations, 'readonly' for queries. All functions return Promises. Use proper error handling with try/catch.

**Avoid:**
- DO NOT implement sync logic here (Plan 05 handles sync)
- DO NOT add network calls (offline-only operations)
- DO NOT use callbacks (Promise-based API only)</action>
  <verify>TypeScript compiles, all CRUD functions defined with proper types, functions use IndexedDB transactions</verify>
  <done>Types extended for offline records, CRUD operations created for all stores with Promise-based API, proper transaction usage, no network calls</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/db/indexeddb.ts created with database initialization
- [ ] All stores defined with appropriate indexes
- [ ] lib/db/stores.ts created with typed CRUD operations
- [ ] lib/db/types.ts extended with offline-specific types
- [ ] TypeScript compiles without errors
- [ ] No network calls in offline storage layer
- [ ] All functions return Promises for async/await support
</verification>

<success_criteria>
- IndexedDB wrapper fully functional
- Typed interfaces for all stores
- CRUD operations for expenses, participants, splits, tags, settlements
- Sync queue store ready for sync engine (Plan 05)
- No external dependencies beyond native IndexedDB API
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-offline-foundation/03-03-SUMMARY.md`:

# Phase 3 Plan 3: IndexedDB Offline Storage Summary

**Local database layer with typed CRUD operations for offline-first architecture**

## Accomplishments

- Implemented IndexedDB wrapper with database initialization
- Created all necessary object stores with proper indexes
- Built typed CRUD operations for all entity types
- Extended type definitions for offline-specific records
- Implemented sync queue for operation tracking

## Files Created/Modified

- `lib/db/indexeddb.ts` - IndexedDB wrapper and initialization
- `lib/db/stores.ts` - Typed CRUD operations
- `lib/db/types.ts` - Extended with offline types

## Decisions Made

[Document any IndexedDB design decisions, index choices, or API patterns]

## Issues Encountered

[Browser compatibility issues, IndexedDB quirks, or "None"]

## Next Step

Ready for 03-04-PLAN.md (Setup offline queue for pending operations)
</output>
