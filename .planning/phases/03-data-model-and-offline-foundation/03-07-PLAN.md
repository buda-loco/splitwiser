---
phase: 03-data-model-and-offline-foundation
plan: 07
type: execute
depends_on: ["03-02", "03-03"]
files_modified: [lib/realtime/subscriptions.ts, hooks/useRealtimeExpenses.ts]
---

<objective>
Setup Supabase realtime subscriptions for live updates when other users modify shared expenses.

Purpose: Enable collaborative expense tracking where changes from other users appear instantly. Creates real-time sync for shared expenses without manual refresh.
Output: Realtime subscription manager and React hook for live expense updates.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-02-SUMMARY.md
@.planning/phases/03-data-model-and-offline-foundation/03-03-SUMMARY.md
@lib/supabase/client.ts
@lib/db/stores.ts

**Tech stack available:**
- Supabase Realtime (PostgreSQL replication)
- React 19 with hooks
- IndexedDB for local state
- TypeScript

**Established patterns:**
- Supabase client in lib/supabase/client.ts
- React hooks for component integration
- Local IndexedDB as source of truth

**Real-time requirement from PROJECT.md:**
- Real-time sync via Supabase subscriptions
- Expenses appear immediately for all participants
- Works alongside offline-first architecture
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create realtime subscription manager</name>
  <files>lib/realtime/subscriptions.ts</files>
  <action>Implement RealtimeManager that subscribes to Supabase table changes and updates local IndexedDB.

**Create RealtimeManager class:**

```typescript
import { createClient } from '@/lib/supabase/client';
import { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js';
import * as stores from '@/lib/db/stores';

export type RealtimeEvent = {
  type: 'INSERT' | 'UPDATE' | 'DELETE';
  table: string;
  record: any;
  old_record?: any;
};

export class RealtimeManager {
  private channels: Map<string, RealtimeChannel> = new Map();
  private supabase = createClient();

  // Subscribe to expense changes
  subscribeToExpenses(user_id: string, callback?: (event: RealtimeEvent) => void): () => void {
    const channel_name = `expenses_${user_id}`;

    // Remove existing channel if present
    if (this.channels.has(channel_name)) {
      this.unsubscribe(channel_name);
    }

    // Create new channel with Postgres Changes filter
    const channel = this.supabase
      .channel(channel_name)
      .on(
        'postgres_changes',
        {
          event: '*', // Listen to INSERT, UPDATE, DELETE
          schema: 'public',
          table: 'expenses',
          filter: `created_by_user_id=eq.${user_id}` // Only expenses user has access to
        },
        async (payload: RealtimePostgresChangesPayload<any>) => {
          await this.handleExpenseChange(payload);

          // Call optional callback for UI updates
          if (callback) {
            callback({
              type: payload.eventType as 'INSERT' | 'UPDATE' | 'DELETE',
              table: 'expenses',
              record: payload.new,
              old_record: payload.old
            });
          }
        }
      )
      .subscribe();

    this.channels.set(channel_name, channel);

    // Return unsubscribe function
    return () => this.unsubscribe(channel_name);
  }

  // Subscribe to splits/participants/tags for an expense
  subscribeToExpenseDetails(expense_id: string, callback?: (event: RealtimeEvent) => void): () => void {
    const channel_name = `expense_details_${expense_id}`;

    if (this.channels.has(channel_name)) {
      this.unsubscribe(channel_name);
    }

    const channel = this.supabase
      .channel(channel_name)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'expense_splits',
          filter: `expense_id=eq.${expense_id}`
        },
        async (payload) => {
          await this.handleSplitChange(payload);
          if (callback) {
            callback({
              type: payload.eventType as any,
              table: 'expense_splits',
              record: payload.new,
              old_record: payload.old
            });
          }
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'expense_tags',
          filter: `expense_id=eq.${expense_id}`
        },
        async (payload) => {
          await this.handleTagChange(payload);
          if (callback) {
            callback({
              type: payload.eventType as any,
              table: 'expense_tags',
              record: payload.new
            });
          }
        }
      )
      .subscribe();

    this.channels.set(channel_name, channel);
    return () => this.unsubscribe(channel_name);
  }

  // Handle expense change from realtime
  private async handleExpenseChange(payload: RealtimePostgresChangesPayload<any>): Promise<void> {
    if (payload.eventType === 'INSERT') {
      // Add new expense to local IndexedDB
      await stores.createExpense({ ...payload.new, sync_status: 'synced' });
    } else if (payload.eventType === 'UPDATE') {
      // Update expense in IndexedDB (only if remote is newer)
      const local = await stores.getExpense(payload.new.id);
      if (!local || new Date(payload.new.updated_at) > new Date(local.updated_at)) {
        await stores.updateExpense(payload.new.id, { ...payload.new, sync_status: 'synced' });
      }
    } else if (payload.eventType === 'DELETE') {
      // Soft delete in IndexedDB
      await stores.deleteExpense(payload.old.id);
    }
  }

  // Handle split changes
  private async handleSplitChange(payload: RealtimePostgresChangesPayload<any>): Promise<void> {
    if (payload.eventType === 'INSERT') {
      await stores.createSplit(payload.new);
    } else if (payload.eventType === 'UPDATE') {
      await stores.updateSplit(payload.new.id, payload.new);
    } else if (payload.eventType === 'DELETE') {
      // Delete from local store (splits don't soft delete)
    }
  }

  // Handle tag changes
  private async handleTagChange(payload: RealtimePostgresChangesPayload<any>): Promise<void> {
    if (payload.eventType === 'INSERT') {
      await stores.addTagToExpense(payload.new.expense_id, payload.new.tag);
    } else if (payload.eventType === 'DELETE') {
      await stores.removeTagFromExpense(payload.old.expense_id, payload.old.tag);
    }
  }

  // Unsubscribe from channel
  private unsubscribe(channel_name: string): void {
    const channel = this.channels.get(channel_name);
    if (channel) {
      this.supabase.removeChannel(channel);
      this.channels.delete(channel_name);
    }
  }

  // Unsubscribe all channels
  unsubscribeAll(): void {
    for (const channel_name of this.channels.keys()) {
      this.unsubscribe(channel_name);
    }
  }
}

export const realtimeManager = new RealtimeManager();
```

**Avoid:**
- DO NOT subscribe to all expenses (huge data, use filter by user access)
- DO NOT update IndexedDB blindly (check timestamps to avoid overwriting local pending changes)
- DO NOT forget to unsubscribe on cleanup (memory leaks)</action>
  <verify>TypeScript compiles, RealtimeManager with subscribe methods, handles INSERT/UPDATE/DELETE events, updates IndexedDB</verify>
  <done>RealtimeManager implemented with filtered subscriptions, event handlers updating IndexedDB, unsubscribe functions, timestamp-based conflict avoidance</done>
</task>

<task type="auto">
  <name>Task 2: Create React hook for realtime expense updates</name>
  <files>hooks/useRealtimeExpenses.ts</files>
  <action>Create React hook that subscribes to realtime updates and triggers component re-renders.

**Implement useRealtimeExpenses hook:**

```typescript
'use client';

import { useEffect, useState } from 'react';
import { realtimeManager } from '@/lib/realtime/subscriptions';
import type { RealtimeEvent } from '@/lib/realtime/subscriptions';
import { useAuth } from '@/lib/contexts/AuthContext'; // Assuming auth context exists from Phase 2

export function useRealtimeExpenses() {
  const { user } = useAuth();
  const [lastEvent, setLastEvent] = useState<RealtimeEvent | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    if (!user) return;

    setIsConnected(true);

    // Subscribe to expense changes for current user
    const unsubscribe = realtimeManager.subscribeToExpenses(
      user.id,
      (event) => {
        setLastEvent(event);
        // Trigger re-render by updating state
        // Components can use lastEvent to show notifications
      }
    );

    // Cleanup on unmount
    return () => {
      unsubscribe();
      setIsConnected(false);
    };
  }, [user]);

  return {
    lastEvent,
    isConnected
  };
}

// Hook for single expense details (splits, tags)
export function useRealtimeExpenseDetails(expense_id: string | null) {
  const [lastEvent, setLastEvent] = useState<RealtimeEvent | null>(null);

  useEffect(() => {
    if (!expense_id) return;

    const unsubscribe = realtimeManager.subscribeToExpenseDetails(
      expense_id,
      (event) => {
        setLastEvent(event);
      }
    );

    return () => {
      unsubscribe();
    };
  }, [expense_id]);

  return {
    lastEvent
  };
}
```

**Hook usage example:**
```typescript
function ExpenseList() {
  const { lastEvent, isConnected } = useRealtimeExpenses();
  const [expenses, setExpenses] = useState([]);

  // Fetch expenses from IndexedDB
  useEffect(() => {
    async function loadExpenses() {
      const data = await stores.getExpenses();
      setExpenses(data);
    }
    loadExpenses();
  }, [lastEvent]); // Re-fetch when lastEvent changes

  return (
    <div>
      {isConnected && <div>ðŸŸ¢ Live</div>}
      {expenses.map(expense => <ExpenseRow key={expense.id} expense={expense} />)}
    </div>
  );
}
```

**Avoid:**
- DO NOT fetch from Supabase directly in hook (IndexedDB is source of truth)
- DO NOT create separate subscriptions in multiple components (use single manager)
- DO NOT show real-time indicator when offline (Plan 08 handles connection status)</action>
  <verify>TypeScript compiles, hooks export lastEvent and isConnected, properly cleanup subscriptions, trigger re-renders on events</verify>
  <done>useRealtimeExpenses and useRealtimeExpenseDetails hooks created with subscription management, automatic cleanup, state updates triggering re-renders</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/realtime/subscriptions.ts created with RealtimeManager
- [ ] hooks/useRealtimeExpenses.ts created with React hooks
- [ ] Subscriptions filter by user access (RLS-aware)
- [ ] Events update IndexedDB automatically
- [ ] Timestamp checking prevents overwriting local changes
- [ ] Proper cleanup on unmount
- [ ] TypeScript compiles without errors
</verification>

<success_criteria>
- Realtime subscriptions working for expenses
- Changes from other users appear in local IndexedDB
- React hooks trigger re-renders on updates
- Subscription cleanup prevents memory leaks
- Works alongside offline-first architecture
- Timestamp-based conflict avoidance
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-offline-foundation/03-07-SUMMARY.md`:

# Phase 3 Plan 7: Realtime Subscriptions Summary

**Live updates from Supabase with IndexedDB synchronization**

## Accomplishments

- Implemented RealtimeManager for Supabase subscriptions
- Created filtered subscriptions based on user access
- Built automatic IndexedDB updates from realtime events
- Added timestamp-based conflict avoidance
- Created React hooks for component integration
- Implemented proper cleanup to prevent memory leaks

## Files Created/Modified

- `lib/realtime/subscriptions.ts` - RealtimeManager implementation
- `hooks/useRealtimeExpenses.ts` - React hooks for realtime updates

## Decisions Made

[Document subscription filter strategy, conflict avoidance approach, cleanup patterns]

## Issues Encountered

[Supabase Realtime connection issues, filter problems, or "None"]

## Next Step

Ready for 03-08-PLAN.md (Add connection status detection and sync indicators)
</output>
