---
phase: 03-data-model-and-offline-foundation
plan: 05
type: execute
depends_on: ["03-02", "03-04"]
files_modified: [lib/sync/engine.ts, lib/sync/conflict-resolver.ts]
---

<objective>
Create sync engine that processes offline queue and syncs with Supabase, including conflict resolution for concurrent edits.

Purpose: Bridge the offline and online worlds by syncing queued operations to Supabase when connectivity returns. Handle conflicts when multiple clients edit the same record offline.
Output: Sync engine with automatic sync, manual sync trigger, and conflict resolution strategies.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-02-SUMMARY.md
@.planning/phases/03-data-model-and-offline-foundation/03-04-SUMMARY.md
@lib/offline/queue.ts
@lib/offline/operations.ts
@lib/supabase/client.ts
@lib/db/stores.ts

**Tech stack available:**
- Supabase client with RLS policies
- IndexedDB with operation queue
- QueueManager for queue operations
- TypeScript with strict mode

**Established patterns:**
- Supabase client utilities in lib/supabase/
- Server actions in lib/actions/ (but sync is client-side)
- Promise-based async operations

**Conflict resolution requirement:**
- Last-write-wins for simple cases
- Version-based detection using updated_at timestamps
- Manual resolution for complex conflicts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement conflict detection and resolution strategies</name>
  <files>lib/sync/conflict-resolver.ts</files>
  <action>Create conflict resolver that compares local and remote versions to detect and resolve conflicts.

**Implement ConflictResolver class:**

```typescript
export type ConflictResolution =
  | { strategy: 'local_wins'; merged_record: any }
  | { strategy: 'remote_wins'; merged_record: any }
  | { strategy: 'manual'; local_record: any; remote_record: any; conflicts: string[] };

export class ConflictResolver {
  // Detect if conflict exists by comparing timestamps
  detectConflict(
    local_record: any,
    remote_record: any,
    last_sync_time: string
  ): boolean {
    // Conflict exists if:
    // 1. Remote record updated_at > last_sync_time (remote changed)
    // 2. Local record local_updated_at > last_sync_time (local changed)
    // 3. Both timestamps newer than last sync = concurrent edit
    const remoteChanged = new Date(remote_record.updated_at) > new Date(last_sync_time);
    const localChanged = new Date(local_record.local_updated_at) > new Date(last_sync_time);
    return remoteChanged && localChanged;
  }

  // Resolve conflict using configured strategy
  async resolve(
    operation: Operation,
    local_record: any,
    remote_record: any,
    strategy: 'last_write_wins' | 'manual'
  ): Promise<ConflictResolution> {
    if (strategy === 'last_write_wins') {
      // Compare updated_at timestamps
      const localNewer = new Date(local_record.local_updated_at) >
                         new Date(remote_record.updated_at);

      if (localNewer) {
        return {
          strategy: 'local_wins',
          merged_record: local_record
        };
      } else {
        return {
          strategy: 'remote_wins',
          merged_record: remote_record
        };
      }
    } else {
      // Manual resolution - detect which fields conflict
      const conflicts = this.detectFieldConflicts(local_record, remote_record);
      return {
        strategy: 'manual',
        local_record,
        remote_record,
        conflicts
      };
    }
  }

  // Compare fields to find specific conflicts
  private detectFieldConflicts(local: any, remote: any): string[] {
    const conflicts: string[] = [];
    const fields = ['amount', 'description', 'category', 'expense_date'];

    for (const field of fields) {
      if (local[field] !== remote[field]) {
        conflicts.push(field);
      }
    }

    return conflicts;
  }

  // Merge records using field-level strategy
  mergeRecords(local: any, remote: any, field_strategy: Record<string, 'local' | 'remote'>): any {
    // For manual resolution: merge field by field
    const merged = { ...remote }; // Start with remote as base

    for (const [field, strategy] of Object.entries(field_strategy)) {
      if (strategy === 'local') {
        merged[field] = local[field];
      }
    }

    return merged;
  }
}

export const conflictResolver = new ConflictResolver();
```

**Avoid:**
- DO NOT use complex CRDTs (too heavy for MVP, save for later optimization)
- DO NOT auto-merge without detection (silent data loss risk)
- DO NOT implement UI for manual resolution here (Plan 06 handles UI)</action>
  <verify>TypeScript compiles, ConflictResolver class with detection and resolution methods, returns properly typed ConflictResolution</verify>
  <done>ConflictResolver implemented with timestamp-based detection, last-write-wins strategy, manual resolution support, field-level conflict detection</done>
</task>

<task type="auto">
  <name>Task 2: Implement sync engine with operation processing</name>
  <files>lib/sync/engine.ts</files>
  <action>Create SyncEngine class that processes the operation queue and syncs with Supabase.

**Implement SyncEngine class:**

```typescript
import { queueManager } from '@/lib/offline/queue';
import { conflictResolver } from '@/lib/sync/conflict-resolver';
import { createClient } from '@/lib/supabase/client';

export type SyncStatus = {
  is_syncing: boolean;
  pending_operations: number;
  last_sync: string | null;
  sync_errors: string[];
};

export class SyncEngine {
  private syncing = false;
  private lastSyncTime: string | null = null;

  // Main sync method - processes entire queue
  async sync(): Promise<SyncStatus> {
    if (this.syncing) {
      return this.getStatus(); // Already syncing, return current status
    }

    this.syncing = true;
    const errors: string[] = [];

    try {
      const supabase = createClient();
      const operations = await queueManager.getPending();

      // Process operations in order (FIFO)
      for (const operation of operations) {
        try {
          await this.processOperation(operation, supabase);
          await queueManager.markSynced(operation.id);
        } catch (error: any) {
          errors.push(`Operation ${operation.id}: ${error.message}`);
          await queueManager.markFailed(operation.id, error.message);
        }
      }

      this.lastSyncTime = new Date().toISOString();
    } finally {
      this.syncing = false;
    }

    return this.getStatus();
  }

  // Process single operation
  private async processOperation(operation: Operation, supabase: any): Promise<void> {
    const { table, operation_type, record_id, payload } = operation;

    if (operation_type === 'create') {
      // INSERT into Supabase
      const { error } = await supabase
        .from(table)
        .insert(payload);

      if (error) throw error;

    } else if (operation_type === 'update') {
      // Check for conflicts first
      const { data: remote_record, error: fetch_error } = await supabase
        .from(table)
        .select('*')
        .eq('id', record_id)
        .single();

      if (fetch_error) throw fetch_error;

      // Detect conflict
      const has_conflict = conflictResolver.detectConflict(
        payload, // local version
        remote_record, // remote version
        this.lastSyncTime || operation.timestamp
      );

      if (has_conflict) {
        // Resolve using last-write-wins
        const resolution = await conflictResolver.resolve(
          operation,
          payload,
          remote_record,
          'last_write_wins'
        );

        if (resolution.strategy === 'local_wins') {
          // Update Supabase with local version
          const { error } = await supabase
            .from(table)
            .update(resolution.merged_record)
            .eq('id', record_id);

          if (error) throw error;
        } else {
          // Remote wins - update local IndexedDB
          // (Pull remote changes into local store)
          await this.updateLocalStore(table, record_id, resolution.merged_record);
        }
      } else {
        // No conflict - simple update
        const { error } = await supabase
          .from(table)
          .update(payload)
          .eq('id', record_id);

        if (error) throw error;
      }

    } else if (operation_type === 'delete') {
      // Soft delete (set is_deleted = true, deleted_at = now())
      const { error } = await supabase
        .from(table)
        .update({ is_deleted: true, deleted_at: new Date().toISOString() })
        .eq('id', record_id);

      if (error) throw error;
    }
  }

  // Update local IndexedDB when remote wins conflict
  private async updateLocalStore(table: string, record_id: string, record: any): Promise<void> {
    // Import appropriate store function based on table
    // Call updateExpense, updateSplit, etc. from stores.ts
    // This keeps IndexedDB in sync with Supabase after remote-wins resolution
  }

  // Get current sync status
  getStatus(): SyncStatus {
    return {
      is_syncing: this.syncing,
      pending_operations: 0, // Will be populated by queueManager.getQueueSize()
      last_sync: this.lastSyncTime,
      sync_errors: []
    };
  }

  // Manual sync trigger for UI
  async triggerSync(): Promise<void> {
    await this.sync();
  }

  // Check if sync is needed (has pending operations)
  async needsSync(): Promise<boolean> {
    const { pending } = await queueManager.getQueueSize();
    return pending > 0;
  }
}

export const syncEngine = new SyncEngine();
```

**Avoid:**
- DO NOT implement automatic sync on connectivity change here (Plan 06 handles that)
- DO NOT add UI notifications for sync status (Plan 06 handles that)
- DO NOT implement retry with exponential backoff yet (optimization for later)
- DO NOT sync on every operation (manual trigger only for now)</action>
  <verify>TypeScript compiles, SyncEngine with sync(), processOperation(), getStatus() methods, handles all operation types and conflicts</verify>
  <done>SyncEngine implemented with queue processing, Supabase integration, conflict resolution for updates, support for create/update/delete operations, status tracking</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] lib/sync/conflict-resolver.ts created with ConflictResolver class
- [ ] lib/sync/engine.ts created with SyncEngine class
- [ ] Conflict detection uses timestamps correctly
- [ ] All operation types (create/update/delete) handled
- [ ] Sync processes queue in FIFO order
- [ ] TypeScript compiles without errors
- [ ] Supabase integration working (client.ts)
</verification>

<success_criteria>
- Sync engine processes offline queue to Supabase
- Conflicts detected using timestamp comparison
- Last-write-wins resolution strategy implemented
- Operations marked as synced/failed appropriately
- Local IndexedDB updated when remote wins
- Manual sync trigger available for UI
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-model-and-offline-foundation/03-05-SUMMARY.md`:

# Phase 3 Plan 5: Sync Engine and Conflict Resolution Summary

**Bidirectional sync between IndexedDB and Supabase with conflict resolution**

## Accomplishments

- Implemented conflict detection using timestamp comparison
- Created ConflictResolver with last-write-wins strategy
- Built SyncEngine that processes operation queue
- Integrated with Supabase for create/update/delete operations
- Implemented conflict resolution for concurrent edits
- Added sync status tracking

## Files Created/Modified

- `lib/sync/conflict-resolver.ts` - Conflict detection and resolution
- `lib/sync/engine.ts` - Sync engine implementation

## Decisions Made

[Document sync strategy decisions, conflict resolution choices, timestamp approach]

## Issues Encountered

[Supabase integration issues, conflict resolution edge cases, or "None"]

## Next Step

Ready for 03-06-PLAN.md (Implement optimistic updates for immediate UI feedback)
</output>
