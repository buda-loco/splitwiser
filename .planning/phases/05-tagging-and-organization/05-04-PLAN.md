---
phase: 05-tagging-and-organization
plan: 04
type: execute
depends_on: []
files_modified: [app/tags/page.tsx, components/TagManagement.tsx]
---

<objective>
Build tag management screen for renaming, merging, and deleting tags across all expenses.

Purpose: Enable users to clean up tag organization (fix typos, consolidate duplicates, remove unused tags).
Output: Tag management page with list of all tags, usage count, and rename/merge/delete actions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key files
@lib/db/types.ts
@lib/db/stores.ts
@lib/db/indexeddb.ts

**Tech stack available:** Next.js 15, TypeScript, Tailwind, Framer Motion, IndexedDB
**Established patterns:** iOS-native list views, confirmation dialogs for destructive actions
**Constraining decisions:**
- Phase 3: Tags stored in expense_tags table with expense_id and tag fields
- Tags are normalized to lowercase on creation

**Database operations available:**
- getAllTags() - returns all unique tags
- getExpenses(filters: { tag }) - returns expenses for tag (for counting usage)
- updateTag(oldTag, newTag) - renames tag across all expenses
- mergeTags(sourceTags[], targetTag) - consolidates multiple tags into one
- deleteTag(tag) - removes tag from all expenses
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tag database operations</name>
  <files>lib/db/stores.ts</files>
  <action>
Add tag management operations to stores.ts:

```typescript
/**
 * Rename a tag across all expenses
 */
export async function renameTag(oldTag: string, newTag: string): Promise&lt;void&gt; {
  const db = await initDatabase()
  const normalizedOld = oldTag.toLowerCase()
  const normalizedNew = newTag.toLowerCase()

  if (normalizedOld === normalizedNew) return // No-op

  const transaction = db.transaction([STORES.EXPENSE_TAGS], 'readwrite')
  const store = transaction.objectStore(STORES.EXPENSE_TAGS)
  const tagIndex = store.index('tag')

  // Get all expense_tags with old tag
  const oldTags = await promisifyRequest(tagIndex.getAll(normalizedOld))

  // For each, update to new tag (if new tag doesn't already exist for that expense)
  for (const tag of oldTags) {
    // Check if new tag already exists for this expense
    const expenseIndex = store.index('expense_id')
    const existingTags = await promisifyRequest(expenseIndex.getAll(tag.expense_id))
    const newTagExists = existingTags.some(t => t.tag === normalizedNew)

    if (newTagExists) {
      // Delete old tag (new already exists)
      await promisifyRequest(store.delete(tag.id))
    } else {
      // Update to new tag
      await promisifyRequest(store.put({ ...tag, tag: normalizedNew }))
    }
  }
}

/**
 * Merge multiple tags into a target tag
 */
export async function mergeTags(sourceTags: string[], targetTag: string): Promise&lt;void&gt; {
  // Rename each source tag to target tag (renameTag handles duplicates)
  for (const source of sourceTags) {
    await renameTag(source, targetTag)
  }
}

/**
 * Delete a tag from all expenses
 */
export async function deleteTag(tag: string): Promise&lt;void&gt; {
  const db = await initDatabase()
  const normalizedTag = tag.toLowerCase()

  const transaction = db.transaction([STORES.EXPENSE_TAGS], 'readwrite')
  const store = transaction.objectStore(STORES.EXPENSE_TAGS)
  const tagIndex = store.index('tag')

  const tags = await promisifyRequest(tagIndex.getAll(normalizedTag))

  for (const tagRecord of tags) {
    await promisifyRequest(store.delete(tagRecord.id))
  }
}

/**
 * Get tag usage statistics
 */
export async function getTagStats(): Promise&lt;Map&lt;string, number&gt;&gt; {
  const tags = await getAllTags()
  const stats = new Map&lt;string, number&gt;()

  for (const tag of tags) {
    const expenses = await getExpenses({ tag })
    stats.set(tag, expenses.length)
  }

  return stats
}
```

Why handle duplicate check in rename: Prevents creating duplicate tags for same expense when renaming to existing tag.
Why merge uses rename: Code reuse, handles edge cases consistently.
  </action>
  <verify>renameTag() renames tag across all expenses. mergeTags() consolidates multiple tags. deleteTag() removes tag from all expenses. getTagStats() returns usage counts.</verify>
  <done>Tag management database operations implemented and working correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Create TagManagement component</name>
  <files>components/TagManagement.tsx</files>
  <action>
Create tag management UI component:

```typescript
export function TagManagement() {
  const [tags, setTags] = useState&lt;string[]&gt;([])
  const [tagStats, setTagStats] = useState&lt;Map&lt;string, number&gt;&gt;(new Map())
  const [selectedTags, setSelectedTags] = useState&lt;Set&lt;string&gt;&gt;(new Set())
  const [editingTag, setEditingTag] = useState&lt;string | null&gt;(null)
  const [newTagName, setNewTagName] = useState('')

  // Load tags and stats on mount
  useEffect(() => {
    async function load() {
      const allTags = await getAllTags()
      const stats = await getTagStats()
      setTags(allTags.sort())
      setTagStats(stats)
    }
    load()
  }, [])

  // Rename tag handler
  async function handleRename(oldTag: string) {
    if (!newTagName || newTagName === oldTag) return
    await renameTag(oldTag, newTagName)
    // Reload tags
    setEditingTag(null)
    setNewTagName('')
    // Refresh data
  }

  // Merge tags handler
  async function handleMerge() {
    if (selectedTags.size < 2) return
    const [target, ...sources] = Array.from(selectedTags)
    await mergeTags(sources, target)
    setSelectedTags(new Set())
    // Refresh data
  }

  // Delete tag handler
  async function handleDelete(tag: string) {
    if (!confirm(`Delete tag "${tag}" from ${tagStats.get(tag)} expenses?`)) return
    await deleteTag(tag)
    // Refresh data
  }

  return (
    &lt;div className="p-4"&gt;
      {/* Merge button - enabled when 2+ tags selected */}
      {selectedTags.size >= 2 && (
        &lt;button onClick={handleMerge}&gt;
          Merge {selectedTags.size} tags
        &lt;/button&gt;
      )}

      {/* Tag list */}
      {tags.map(tag => (
        &lt;div key={tag} className="iOS-list-row"&gt;
          {/* Checkbox for selection */}
          {/* Tag name (editable if editingTag === tag) */}
          {/* Usage count */}
          {/* Rename button */}
          {/* Delete button */}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  )
}
```

UI details:
- iOS-native list rows (white bg, border-b, dark:bg-gray-900)
- Checkbox on left (rounded, border-gray-300, checked:bg-ios-blue)
- Tag name in center (font-medium, text-base)
- Usage count on right (text-sm text-gray-500 "N expenses")
- Action buttons: Rename (pencil icon), Delete (trash icon)
- Inline edit: Clicking rename shows text input replacing tag name
- Merge button: Fixed at top when 2+ selected (bg-ios-blue, text-white, rounded-lg)
- Confirmation for delete with expense count
- Dark mode support throughout
  </action>
  <verify>Component renders tag list with usage counts. Can select multiple tags. Rename shows inline edit. Merge button appears when 2+ selected. Delete shows confirmation.</verify>
  <done>TagManagement component exists with rename, merge, delete functionality and iOS-native styling.</done>
</task>

<task type="auto">
  <name>Task 3: Create tag management page</name>
  <files>app/tags/page.tsx</files>
  <action>
Create tag management page:

```typescript
export default function TagsPage() {
  return (
    &lt;main className="min-h-screen bg-white dark:bg-black pb-safe"&gt;
      {/* Header */}
      &lt;div className="sticky top-0 bg-white dark:bg-black border-b border-gray-200 dark:border-gray-800 px-4 py-3"&gt;
        &lt;h1 className="text-2xl font-semibold text-black dark:text-white"&gt;
          Manage Tags
        &lt;/h1&gt;
        &lt;p className="text-sm text-gray-500 dark:text-gray-400 mt-1"&gt;
          Rename, merge, or delete tags across all expenses
        &lt;/p&gt;
      &lt;/div&gt;

      {/* Tag management component */}
      &lt;TagManagement /&gt;
    &lt;/main&gt;
  )
}
```

Navigation: Add link to /tags in main navigation or settings (future phase).
For now, users can navigate directly to /tags URL.
  </action>
  <verify>Navigate to /tags shows tag management page. Header displays correctly. TagManagement component renders below.</verify>
  <done>Tag management page created at /tags with header and TagManagement component.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npx tsc --noEmit)
- [ ] renameTag() works correctly across all expenses
- [ ] mergeTags() consolidates multiple tags into one
- [ ] deleteTag() removes tag from all expenses
- [ ] Tag management page renders at /tags
- [ ] Tag list shows all tags with usage counts
- [ ] Can rename tag inline
- [ ] Can select multiple tags and merge
- [ ] Delete shows confirmation with usage count
- [ ] Dark mode styling on all components
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Tag management operations work correctly
- Tag management UI provides rename, merge, delete
- iOS-native styling throughout
- Confirmation dialogs prevent accidental data loss
</success_criteria>

<output>
After completion, create `.planning/phases/05-tagging-and-organization/05-04-SUMMARY.md`
</output>
