---
phase: 11-analytics-export-and-categories
plan: 14
type: execute
depends_on: []
files_modified: [lib/ratelimit/upstash.ts, middleware.ts, lib/ratelimit/errors.ts, package.json]
---

<objective>
Implement API rate limiting using Upstash Redis to prevent abuse and ensure fair usage.

Purpose: Protect API endpoints from abuse, brute force attacks, and excessive requests.
Output: Rate limiting middleware, Upstash Redis integration, rate limit error handling with user feedback.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@middleware.ts

**Tech stack available:** Next.js middleware, Edge Runtime compatible libraries
**Decision:** Use Upstash Redis (free tier: 10k commands/day, edge-compatible, serverless)
**Current state:** Middleware exists for auth session refresh, no rate limiting
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup Upstash Redis for rate limiting</name>
  <files>package.json, lib/ratelimit/upstash.ts</files>
  <action>Install @upstash/ratelimit and @upstash/redis libraries: npm install @upstash/ratelimit @upstash/redis. Create free Upstash Redis database via Upstash dashboard (upstash.com), copy REST URL and token to .env.local (UPSTASH_REDIS_REST_URL, UPSTASH_REDIS_REST_TOKEN). Create upstash.ts: initialize Upstash Redis client using REST API (edge-compatible). Create rate limiter instances: 1) apiLimiter (10 requests per minute per IP for API routes), 2) authLimiter (5 requests per minute per IP for auth routes, stricter to prevent brute force), 3) expenseLimiter (30 requests per minute per user for expense CRUD). Use sliding window algorithm. Export rateLimit(identifier, limiter) async function that checks limit and returns {success: boolean, remaining: number, reset: Date}.</action>
  <verify>Upstash Redis client connects successfully, rate limiter instances created, rateLimit() function returns correct structure, TypeScript compiles</verify>
  <done>Upstash Redis integration with rate limiter instances</done>
</task>

<task type="auto">
  <name>Task 2: Implement rate limiting middleware</name>
  <files>middleware.ts</files>
  <action>Update Next.js middleware to add rate limiting before auth checks. Steps: 1) Extract IP address from request headers (x-forwarded-for or request.ip), 2) Determine which limiter to use based on pathname (authLimiter for /api/auth/*, apiLimiter for other /api/* routes, skip for static files), 3) Call rateLimit(ip, limiter), 4) If !success, return 429 Too Many Requests response with Retry-After header (calculated from reset time), 5) If success, add rate limit headers to response: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, 6) Continue to auth middleware. For authenticated users on expense routes, use userId instead of IP as identifier (more accurate). Skip rate limiting in development mode (process.env.NODE_ENV !== 'production').</action>
  <verify>Middleware runs on API routes, rate limits applied correctly, 429 response returned when limit exceeded, headers included in response, development mode skipped</verify>
  <done>Rate limiting middleware integrated into Next.js middleware</done>
</task>

<task type="auto">
  <name>Task 3: Add rate limit error handling and user feedback</name>
  <files>lib/ratelimit/errors.ts, components/RateLimitToast.tsx</files>
  <action>Create custom RateLimitError class with status code 429, retry-after timestamp. In API error handling (lib/actions or API routes), catch 429 errors and throw RateLimitError with clear message: "Too many requests. Please wait [X seconds] before trying again." Create RateLimitToast component that displays when rate limit hit: iOS-native toast notification (slide from top, auto-dismiss after retry-after duration), shows countdown timer ("Try again in 45 seconds..."), styled with ios-red background. Add global error handler in app layout to show RateLimitToast when API returns 429. For CLI/API clients, ensure 429 response includes JSON body: {error: "Rate limit exceeded", retryAfter: seconds, limit: number, reset: timestamp}.</action>
  <verify>RateLimitError thrown when limit exceeded, toast displays with countdown, auto-dismisses after retry period, API clients receive proper JSON error response</verify>
  <done>Rate limit error handling with user-friendly feedback and countdown</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Upstash Redis database created and connected
- [ ] Rate limiter instances configured correctly
- [ ] Middleware applies rate limiting to API routes
- [ ] 429 response returned when limit exceeded
- [ ] Rate limit headers included in responses
- [ ] RateLimitToast displays on rate limit hit
- [ ] Countdown timer shows remaining wait time
- [ ] Development mode skips rate limiting
- [ ] Authenticated users rate-limited by userId, not IP
</verification>

<success_criteria>

- All tasks completed
- Rate limiting protects all API endpoints
- Upstash Redis integration functional
- User feedback clear and helpful
- Fair usage enforced
</success_criteria>

<output>
After completion, create `.planning/phases/11-analytics-export-and-categories/11-14-SUMMARY.md`
</output>
