---
phase: 08-templates-and-efficiency-features
plan: 04
type: execute
depends_on: ["08-01", "08-02"]
files_modified: [app/templates/page.tsx, components/TemplateList.tsx, app/templates/[id]/edit/page.tsx]
---

<objective>
Build template management screen with list, edit, and delete capabilities.

Purpose: Allow users to view all saved templates, edit configurations, and delete templates they no longer need.
Output: Template list page with edit/delete actions, and edit page for updating template configurations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-templates-and-efficiency-features/08-01-SUMMARY.md
@.planning/phases/08-templates-and-efficiency-features/08-02-SUMMARY.md
@components/ExpenseList.tsx
@components/TemplateForm.tsx
@lib/db/types.ts
@lib/db/stores.ts
@hooks/useTemplates.ts

**Tech stack available:** Next.js 15, React, TypeScript, Tailwind, Framer Motion
**Established patterns:**
- List components with iOS-native row styling (ExpenseList as reference)
- Edit pages with form pre-population
- Delete confirmations with iOS alert-style modals
- Framer Motion animations for list items and page transitions

**From 08-01:**
- CRUD operations: getTemplatesByUser, getTemplateById, updateTemplate, deleteTemplate

**From 08-02:**
- TemplateForm component ready for editing mode

**From 08-03:**
- useTemplates hook for fetching templates
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TemplateList component and templates list page</name>
  <files>components/TemplateList.tsx, app/templates/page.tsx</files>
  <action>
Create TemplateList component following ExpenseList.tsx patterns:

**TemplateList.tsx:**
```typescript
'use client';

import { useState } from 'react';
import { motion } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { deleteTemplate } from '@/lib/db/stores';
import type { OfflineSplitTemplate } from '@/lib/db/types';

export function TemplateList({ templates }: { templates: OfflineSplitTemplate[] }) {
  const router = useRouter();
  const [deletingId, setDeletingId] = useState<string | null>(null);

  async function handleDelete(templateId: string) {
    // Show confirmation (iOS-style alert)
    const confirmed = window.confirm('Delete this template? This cannot be undone.');
    if (!confirmed) return;

    setDeletingId(templateId);
    try {
      await deleteTemplate(templateId);
      // Trigger re-render by navigating to same page (Next.js will refetch)
      router.refresh();
    } catch (error) {
      console.error('Failed to delete template:', error);
      alert('Failed to delete template. Please try again.');
    } finally {
      setDeletingId(null);
    }
  }

  if (templates.length === 0) {
    return (
      <div className="text-center py-12">
        <p className="text-ios-gray dark:text-ios-gray3 text-base mb-4">
          No templates yet
        </p>
        <button
          onClick={() => router.push('/templates/new')}
          className="text-ios-blue text-base font-medium"
        >
          Create your first template
        </button>
      </div>
    );
  }

  return (
    <div className="space-y-2">
      {templates.map((template) => (
        <motion.div
          key={template.id}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="bg-white dark:bg-ios-gray1 rounded-xl p-4 shadow-sm"
        >
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <h3 className="text-base font-semibold text-ios-black dark:text-white mb-1">
                {template.name}
              </h3>
              <p className="text-sm text-ios-gray dark:text-ios-gray3 capitalize">
                Split type: {template.split_type}
              </p>
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => router.push(`/templates/${template.id}/edit`)}
                className="px-3 py-1.5 text-sm font-medium text-ios-blue bg-ios-blue/10 rounded-lg hover:bg-ios-blue/20 active:scale-95 transition-all"
                disabled={deletingId === template.id}
              >
                Edit
              </button>
              <button
                onClick={() => handleDelete(template.id)}
                className="px-3 py-1.5 text-sm font-medium text-ios-red bg-ios-red/10 rounded-lg hover:bg-ios-red/20 active:scale-95 transition-all disabled:opacity-50"
                disabled={deletingId === template.id}
              >
                {deletingId === template.id ? 'Deleting...' : 'Delete'}
              </button>
            </div>
          </div>
        </motion.div>
      ))}
    </div>
  );
}
```

**app/templates/page.tsx:**
```typescript
'use client';

import { useRouter } from 'next/navigation';
import { TemplateList } from '@/components/TemplateList';
import { useTemplates } from '@/hooks/useTemplates';

export default function TemplatesPage() {
  const router = useRouter();
  const userId = 'temp-user-id'; // TODO: Get from auth context
  const { templates, loading } = useTemplates(userId);

  return (
    <div className="min-h-screen bg-ios-gray6 dark:bg-black pb-safe">
      <div className="max-w-2xl mx-auto px-4 pt-safe">
        {/* Header */}
        <div className="flex items-center justify-between py-4 mb-4">
          <h1 className="text-2xl font-bold text-ios-black dark:text-white">
            Templates
          </h1>
          <button
            onClick={() => router.push('/templates/new')}
            className="px-4 py-2 bg-ios-blue text-white rounded-xl font-medium active:scale-95 transition-transform"
          >
            + New Template
          </button>
        </div>

        {/* Template List */}
        {loading ? (
          <div className="text-center py-12 text-ios-gray dark:text-ios-gray3">
            Loading templates...
          </div>
        ) : (
          <TemplateList templates={templates} />
        )}
      </div>
    </div>
  );
}
```

Follow ExpenseList patterns: iOS-native row styling, Framer Motion animations, empty state, loading state.
Use window.confirm for delete confirmation (iOS-style alert, simple and native).
  </action>
  <verify>TypeScript compiles without errors, templates list page renders with empty state</verify>
  <done>TemplateList component and templates list page created with edit/delete actions, iOS-native styling</done>
</task>

<task type="auto">
  <name>Task 2: Create template edit page with form pre-population</name>
  <files>app/templates/[id]/edit/page.tsx</files>
  <action>
Create edit page following Next.js dynamic route pattern:

```typescript
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import { TemplateForm } from '@/components/TemplateForm';
import { getTemplateById, updateTemplate, deleteTemplate, getParticipantById } from '@/lib/db/stores';
import type { TemplateFormData } from '@/components/TemplateForm';
import type { TemplateParticipant } from '@/lib/db/types';
import type { ParticipantWithDetails } from '@/hooks/useParticipants';

export default function EditTemplatePage() {
  const params = useParams();
  const router = useRouter();
  const templateId = params.id as string;

  const [initialData, setInitialData] = useState<TemplateFormData | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadTemplate() {
      try {
        const result = await getTemplateById(templateId);
        if (!result) {
          alert('Template not found');
          router.push('/templates');
          return;
        }

        const { template, participants: templateParticipants } = result;

        // Load full participant details
        const participantDetails: ParticipantWithDetails[] = await Promise.all(
          templateParticipants.map(async (tp: TemplateParticipant) => {
            if (tp.participant_id) {
              const p = await getParticipantById(tp.participant_id);
              return p ? {
                id: tp.participant_id,
                type: 'participant' as const,
                name: p.name,
                email: p.email,
                phone: p.phone,
                split_value: tp.split_value
              } : null;
            } else if (tp.user_id) {
              // TODO: Load user details when getUserById exists
              return {
                id: tp.user_id,
                type: 'user' as const,
                name: 'User',
                split_value: tp.split_value
              };
            }
            return null;
          })
        ).then(results => results.filter(Boolean) as ParticipantWithDetails[]);

        // Create splits from template participants
        const splits = participantDetails.map(p => ({
          user_id: p.type === 'user' ? p.id : null,
          participant_id: p.type === 'participant' ? p.id : null,
          split_value: p.split_value || null
        }));

        setInitialData({
          name: template.name,
          split_type: template.split_type,
          participants: participantDetails,
          splits
        });
      } catch (error) {
        console.error('Failed to load template:', error);
        alert('Failed to load template');
        router.push('/templates');
      } finally {
        setLoading(false);
      }
    }

    loadTemplate();
  }, [templateId, router]);

  async function handleSubmit(formData: TemplateFormData) {
    try {
      // Delete old template and participants
      await deleteTemplate(templateId);

      // Create new template with updated data (simpler than update logic)
      const userId = 'temp-user-id'; // TODO: Get from auth context
      const { createTemplate } = await import('@/lib/db/stores');
      await createTemplate({
        name: formData.name,
        split_type: formData.split_type,
        created_by_user_id: userId,
        participants: formData.participants.map(p => ({
          user_id: p.type === 'user' ? p.id : null,
          participant_id: p.type === 'participant' ? p.id : null,
          split_value: formData.split_type === 'equal' ? null : (p.split_value || null)
        }))
      });

      router.push('/templates');
    } catch (error) {
      console.error('Failed to update template:', error);
      alert('Failed to update template. Please try again.');
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-ios-gray6 dark:bg-black flex items-center justify-center">
        <p className="text-ios-gray dark:text-ios-gray3">Loading template...</p>
      </div>
    );
  }

  if (!initialData) {
    return null;
  }

  return (
    <div className="min-h-screen bg-ios-gray6 dark:bg-black pb-safe">
      <div className="max-w-2xl mx-auto px-4 pt-safe">
        <h1 className="text-2xl font-bold text-ios-black dark:text-white py-4 mb-4">
          Edit Template
        </h1>
        <TemplateForm
          initialData={initialData}
          onSubmit={handleSubmit}
          onCancel={() => router.push('/templates')}
        />
      </div>
    </div>
  );
}
```

**Update strategy:** Delete old + create new is simpler than updating template and participants separately (avoids complex participant diff logic).
This matches the expense edit pattern where full replacement is easier than granular updates.

Add TODO comments for getUserById (doesn't exist yet).
Use getParticipantById which already exists from Phase 2.
  </action>
  <verify>TypeScript compiles without errors, edit page loads template data and pre-populates form</verify>
  <done>Template edit page created with form pre-population, delete-and-recreate update strategy, navigation back to list after save</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (`npx tsc --noEmit`)
- [ ] Templates list page shows all user templates
- [ ] Empty state displays when no templates exist
- [ ] Edit button navigates to edit page with pre-populated form
- [ ] Delete button shows confirmation and removes template
- [ ] Edit page saves changes and returns to list
- [ ] All iOS-native styling matches existing patterns
</verification>

<success_criteria>

- TemplateList component created with edit/delete actions
- Templates list page displays all templates with loading and empty states
- Template edit page loads and pre-populates TemplateForm
- Delete confirmation prevents accidental deletions
- Edit saves via delete-and-recreate strategy
- Navigation flows work correctly (list → edit → list, list → new → list)
- All verification checks pass
- No TypeScript errors introduced
- Phase 8 complete: Templates & Efficiency Features
  </success_criteria>

<output>
After completion, create `.planning/phases/08-templates-and-efficiency-features/08-04-SUMMARY.md`:

# Phase 8 Plan 4: Template Management UI Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `file.tsx` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 8 complete! Ready for Phase 9: Version History & Undo
</output>
