---
phase: 08-templates-and-efficiency-features
plan: 01
type: execute
depends_on: []
files_modified: [supabase/migrations/20260206000008_create_templates.sql, lib/db/types.ts, lib/db/stores.ts]
---

<objective>
Create database schema and CRUD operations for split templates.

Purpose: Establish the data foundation for storing named split configurations with participants and weights that can be reused across expenses.
Output: Template schema in database, TypeScript types, and IndexedDB CRUD operations ready for UI integration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/db/types.ts
@lib/db/stores.ts
@supabase/migrations/20260206000001_create_core_schema.sql

**Tech stack available:** Next.js 15, Supabase (Postgres + Auth), IndexedDB, TypeScript
**Established patterns:**
- Decimal(12,2) for money amounts, not float
- timestamptz for timestamps
- uuid primary keys
- IndexedDB mirrors Postgres schema with sync_status field
- CRUD operations return Promise with type safety

**Constraining decisions:**
- Phase 3: Offline-first architecture with IndexedDB + sync queue
- Phase 4: Split types are 'equal' | 'percentage' | 'shares' | 'exact'
- Phase 4: Participants can be users (user_id) or non-registered participants (participant_id)

**Templates need to store:**
- Template name (e.g., "Family Dinner")
- Associated participants with split configuration
- Split type and weights/percentages/shares per participant
- Created by user (for ownership)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template database schema migration</name>
  <files>supabase/migrations/20260206000008_create_templates.sql</files>
  <action>
Create migration with 2 tables:

**split_templates table:**
- id (uuid primary key default gen_random_uuid())
- name (text not null, 1-100 chars)
- split_type (text not null, check in ('equal', 'percentage', 'shares', 'exact'))
- created_by_user_id (uuid not null references auth.users(id) on delete cascade)
- created_at (timestamptz default now())
- updated_at (timestamptz default now())
- Index on created_by_user_id for fast user template queries
- Unique constraint on (created_by_user_id, name) to prevent duplicate template names per user

**template_participants table:**
- id (uuid primary key default gen_random_uuid())
- template_id (uuid not null references split_templates(id) on delete cascade)
- user_id (uuid references auth.users(id) on delete cascade)
- participant_id (uuid references participants(id) on delete cascade)
- split_value (decimal(12,2) - percentage/shares/exact amount, null for equal split)
- created_at (timestamptz default now())
- Check constraint: (user_id IS NOT NULL AND participant_id IS NULL) OR (user_id IS NULL AND participant_id IS NOT NULL)
- Index on template_id for fast lookups

Enable RLS on both tables:
- SELECT: Users can view their own templates
- INSERT: Users can create templates (must set created_by_user_id to auth.uid())
- UPDATE: Users can update their own templates
- DELETE: Users can delete their own templates

Use same RLS helper pattern from 20260206000002_create_rls_policies.sql.
  </action>
  <verify>Migration file exists, run `npx supabase db diff` to validate SQL syntax (or check file manually)</verify>
  <done>Migration file created with 2 tables, indexes, constraints, and RLS policies</done>
</task>

<task type="auto">
  <name>Task 2: Add TypeScript types for templates</name>
  <files>lib/db/types.ts</files>
  <action>
Add template types after ExpenseTag type definition:

```typescript
/**
 * Split template record for storing reusable split configurations
 */
export type SplitTemplate = {
  id: string;
  name: string;
  split_type: 'equal' | 'percentage' | 'shares' | 'exact';
  created_by_user_id: string;
  created_at: string;
  updated_at: string;
};

/**
 * Offline-specific template type with sync tracking
 */
export type OfflineSplitTemplate = SplitTemplate & {
  sync_status: 'pending' | 'synced' | 'conflict';
  local_updated_at: string;
};

/**
 * Template participant record linking templates to users/participants with split values
 */
export type TemplateParticipant = {
  id: string;
  template_id: string;
  user_id: string | null;
  participant_id: string | null;
  split_value: number | null; // null for equal split, number for percentage/shares/exact
  created_at: string;
};

/**
 * Input type for creating a template
 */
export type TemplateCreateInput = {
  name: string;
  split_type: SplitTemplate['split_type'];
  created_by_user_id: string;
  participants: Array<{
    user_id?: string | null;
    participant_id?: string | null;
    split_value?: number | null;
  }>;
};
```

Follow existing type patterns: base type, offline variant with sync_status, create input type.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Template types added to lib/db/types.ts, no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 3: Implement IndexedDB CRUD for templates</name>
  <files>lib/db/stores.ts</files>
  <action>
Add IndexedDB operations for templates after settlement operations:

**Add to initDB():**
- Object store: 'split_templates' with indexes: created_by_user_id, sync_status
- Object store: 'template_participants' with index: template_id

**CRUD operations:**

```typescript
// Create template with participants (atomic transaction)
export async function createTemplate(template: TemplateCreateInput): Promise<OfflineSplitTemplate> {
  const db = await initDB();
  const tx = db.transaction(['split_templates', 'template_participants'], 'readwrite');

  const templateRecord: OfflineSplitTemplate = {
    id: crypto.randomUUID(),
    name: template.name,
    split_type: template.split_type,
    created_by_user_id: template.created_by_user_id,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    sync_status: 'pending',
    local_updated_at: new Date().toISOString()
  };

  await tx.objectStore('split_templates').add(templateRecord);

  for (const p of template.participants) {
    const participantRecord: TemplateParticipant = {
      id: crypto.randomUUID(),
      template_id: templateRecord.id,
      user_id: p.user_id || null,
      participant_id: p.participant_id || null,
      split_value: p.split_value || null,
      created_at: new Date().toISOString()
    };
    await tx.objectStore('template_participants').add(participantRecord);
  }

  await tx.done;
  return templateRecord;
}

// Get all templates for user
export async function getTemplatesByUser(userId: string): Promise<OfflineSplitTemplate[]> {
  const db = await initDB();
  const index = db.transaction('split_templates').store.index('created_by_user_id');
  return await index.getAll(userId);
}

// Get template by ID with participants
export async function getTemplateById(templateId: string): Promise<{ template: OfflineSplitTemplate; participants: TemplateParticipant[] } | null> {
  const db = await initDB();
  const template = await db.get('split_templates', templateId);
  if (!template) return null;

  const participantsIndex = db.transaction('template_participants').store.index('template_id');
  const participants = await participantsIndex.getAll(templateId);

  return { template, participants };
}

// Update template (name or split_type only)
export async function updateTemplate(templateId: string, updates: { name?: string; split_type?: SplitTemplate['split_type'] }): Promise<void> {
  const db = await initDB();
  const template = await db.get('split_templates', templateId);
  if (!template) throw new Error('Template not found');

  const updated = {
    ...template,
    ...updates,
    updated_at: new Date().toISOString(),
    sync_status: 'pending' as const,
    local_updated_at: new Date().toISOString()
  };

  await db.put('split_templates', updated);
}

// Delete template (cascades to participants via transaction)
export async function deleteTemplate(templateId: string): Promise<void> {
  const db = await initDB();
  const tx = db.transaction(['split_templates', 'template_participants'], 'readwrite');

  // Delete all participants first
  const participantsIndex = tx.objectStore('template_participants').index('template_id');
  const participants = await participantsIndex.getAll(templateId);
  for (const p of participants) {
    await tx.objectStore('template_participants').delete(p.id);
  }

  // Delete template
  await tx.objectStore('split_templates').delete(templateId);
  await tx.done;
}
```

Use existing patterns: crypto.randomUUID(), sync_status: 'pending', transactions for atomicity.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Template CRUD operations added to lib/db/stores.ts, no TypeScript errors, atomic transactions for create/delete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Migration file syntax is valid SQL
- [ ] TypeScript compiles without errors (`npx tsc --noEmit`)
- [ ] Template types follow existing patterns (base type, offline variant, create input)
- [ ] IndexedDB operations use transactions for atomicity
- [ ] RLS policies secure templates per user
</verification>

<success_criteria>

- Migration file created with split_templates and template_participants tables
- RLS policies enable users to CRUD their own templates only
- TypeScript types added for SplitTemplate, OfflineSplitTemplate, TemplateParticipant, TemplateCreateInput
- IndexedDB stores initialized with proper indexes
- CRUD operations implemented: create, getByUser, getById, update, delete
- All verification checks pass
- No TypeScript errors introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/08-templates-and-efficiency-features/08-01-SUMMARY.md`:

# Phase 8 Plan 1: Template Schema & CRUD Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 08-02-PLAN.md and 08-03-PLAN.md (can run in parallel - independent files)
</output>
