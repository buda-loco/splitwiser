---
phase: 09-version-history-and-undo
plan: 03
type: execute
depends_on: ["09-01"]
files_modified: [lib/db/stores.ts, components/ExpenseDetail.tsx]
---

<objective>
Build undo system allowing users to restore previous versions of expenses.

Purpose: Enable mistake recovery and version rollback for user confidence.
Output: Undo functionality integrated into expense detail page with version restoration capability.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-version-history-and-undo/09-01-SUMMARY.md
@components/ExpenseDetail.tsx
@lib/db/types.ts
@lib/db/stores.ts

**Tech stack available:** Next.js 15, React, TypeScript, IndexedDB
**Established patterns:**
- Confirmation dialogs with window.confirm
- Optimistic updates with useOptimisticMutation
- Router.refresh() for re-rendering after changes
- Transaction-based atomic operations

**From 09-01:**
- restoreExpense(id, userId) function exists
- getExpenseVersion(expense_id, version_number) returns specific version
- OfflineExpenseVersion with changes.before and changes.after
- recordExpenseVersion tracks all changes
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement revertToVersion function</name>
  <files>lib/db/stores.ts</files>
  <action>
Create function to revert expense to a previous version:

```typescript
export async function revertExpenseToVersion(
  expense_id: string,
  version_number: number,
  userId: string
): Promise<void> {
  const db = await initDB();
  const tx = db.transaction(['expenses', 'expense_versions'], 'readwrite');

  // Get target version
  const targetVersion = await getExpenseVersion(expense_id, version_number);
  if (!targetVersion) {
    throw new Error('Version not found');
  }

  // Get current expense
  const expense = await tx.objectStore('expenses').get(expense_id);
  if (!expense) {
    throw new Error('Expense not found');
  }

  // Capture current state for version history
  const beforeRevert = {
    amount: expense.amount,
    description: expense.description,
    category: expense.category,
    expense_date: expense.expense_date
  };

  // Apply target version's "after" state
  const targetState = targetVersion.changes.after;
  if (targetState) {
    expense.amount = targetState.amount ?? expense.amount;
    expense.description = targetState.description ?? expense.description;
    expense.category = targetState.category ?? expense.category;
    expense.expense_date = targetState.expense_date ?? expense.expense_date;
    expense.version += 1;
    expense.updated_at = new Date().toISOString();
    expense.sync_status = 'pending';
    expense.local_updated_at = new Date().toISOString();

    await tx.objectStore('expenses').put(expense);

    // Record this revert as an update
    await recordExpenseVersion(
      expense_id,
      userId,
      'updated',
      beforeRevert,
      targetState
    );
  }

  await tx.done;
}
```

Use transaction to ensure atomicity.
Increment version number (revert creates new version, doesn't delete history).
Record the revert as an 'updated' change for audit trail.
Don't try to revert participants or splits - just basic expense fields.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>revertExpenseToVersion function implemented with atomic transaction, version tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add undo UI to expense detail page</name>
  <files>components/ExpenseDetail.tsx</files>
  <action>
Add "Undo Last Change" button to ExpenseDetail component:

1. Import revertExpenseToVersion
2. Load latest version using getExpenseVersions(expenseId) - take first item (most recent)
3. Add button next to Edit/Delete buttons:

```typescript
const [versions, setVersions] = useState<OfflineExpenseVersion[]>([]);

useEffect(() => {
  async function loadVersions() {
    const v = await getExpenseVersions(expense.id);
    setVersions(v);
  }
  loadVersions();
}, [expense.id]);

const canUndo = versions.length > 1; // Need at least 2 versions (current + previous)
const previousVersion = versions[1]; // Second item is previous version

async function handleUndo() {
  if (!canUndo || !previousVersion) return;

  const confirmed = window.confirm(
    `Undo last change? This will revert to version ${previousVersion.version_number}.`
  );
  if (!confirmed) return;

  try {
    const userId = 'temp-user-id'; // TODO: Get from auth context
    await revertExpenseToVersion(expense.id, previousVersion.version_number, userId);
    router.refresh(); // Re-fetch data
  } catch (error) {
    console.error('Failed to undo:', error);
    alert('Failed to undo change. Please try again.');
  }
}

// In JSX, add button:
{canUndo && (
  <button
    onClick={handleUndo}
    className="px-3 py-1.5 text-sm font-medium text-ios-blue bg-ios-blue/10 rounded-lg hover:bg-ios-blue/20 active:scale-95 transition-all"
  >
    Undo Last Change
  </button>
)}
```

Place Undo button before Edit button in action row.
Only show if there's a previous version to revert to.
Use window.confirm for confirmation (simple, iOS-native).
Call router.refresh() after undo to re-render with updated data.
  </action>
  <verify>Undo button appears when versions exist, clicking undoes last change</verify>
  <done>Undo UI integrated into ExpenseDetail, button shows conditionally, confirmation prevents accidents, router refreshes after undo</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (`npx tsc --noEmit`)
- [ ] revertExpenseToVersion function works correctly
- [ ] Undo button shows only when previous versions exist
- [ ] Clicking Undo shows confirmation dialog
- [ ] After undo, expense reverts to previous state
- [ ] Router refreshes and displays updated expense
- [ ] Undo creates new version record (audit trail)
</verification>

<success_criteria>

- revertExpenseToVersion function implemented with transactions
- Undo button added to ExpenseDetail component
- Conditional rendering based on version history
- Confirmation dialog prevents accidental undo
- Router refresh after undo for instant feedback
- All verification checks pass
- No TypeScript errors introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/09-version-history-and-undo/09-03-SUMMARY.md`:

# Phase 9 Plan 3: Undo System Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 09-04-PLAN.md (activity feed) - depends on 09-01 only
</output>
