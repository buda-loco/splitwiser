---
phase: 09-version-history-and-undo
plan: 01
type: execute
depends_on: []
files_modified: [lib/db/indexeddb.ts, lib/db/stores.ts, lib/db/types.ts]
---

<objective>
Implement change tracking on all expense operations to capture version history.

Purpose: Enable undo capability and activity feed by automatically recording all expense modifications (create, update, delete) in expense_versions table.
Output: All expense CRUD operations now track changes with before/after diffs stored in IndexedDB and synced to Supabase.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-model-and-offline-foundation/03-01-SUMMARY.md
@.planning/phases/04-core-expense-creation/04-07-SUMMARY.md
@lib/db/types.ts
@lib/db/stores.ts
@lib/db/indexeddb.ts
@supabase/migrations/20260206000001_create_core_schema.sql

**Tech stack available:** Next.js 15, React, TypeScript, IndexedDB, Supabase
**Established patterns:**
- IndexedDB stores with sync_status tracking
- Atomic transactions for related operations
- CRUD operations returning Promise with type safety
- Offline-first with optimistic updates

**From Phase 3:**
- expense_versions table exists in Supabase schema
- ExpenseVersion type exists in types.ts
- changes field is jsonb with before/after diff
- change_type: created, updated, deleted, restored

**From Phase 4:**
- createExpense, updateExpense, deleteExpense functions exist
- expenses.version field increments on each update
- Soft delete pattern (is_deleted flag)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IndexedDB store for expense_versions</name>
  <files>lib/db/indexeddb.ts, lib/db/types.ts</files>
  <action>
Update initDB() in indexeddb.ts to create expense_versions object store with indexes:
- Primary key: id
- Index: expense_id (for fetching all versions of an expense)
- Index: sync_status (for sync queue)

Add OfflineExpenseVersion type in types.ts:
```typescript
export type OfflineExpenseVersion = ExpenseVersion & {
  sync_status: 'pending' | 'synced' | 'conflict';
  local_updated_at: string;
};
```

Increment IndexedDB version number (currently at 3, increment to 4).

Use existing patterns from split_templates store (Phase 8) - same index structure.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>IndexedDB version 4 created, expense_versions store exists with expense_id and sync_status indexes, OfflineExpenseVersion type exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement version tracking in CRUD operations</name>
  <files>lib/db/stores.ts</files>
  <action>
Create helper function to record version changes:

```typescript
async function recordExpenseVersion(
  expense_id: string,
  changed_by_user_id: string,
  change_type: 'created' | 'updated' | 'deleted' | 'restored',
  before: Partial<Expense> | null,
  after: Partial<Expense> | null
): Promise<void> {
  const db = await initDB();
  const expense = await db.get('expenses', expense_id);
  if (!expense) return;

  const version: OfflineExpenseVersion = {
    id: crypto.randomUUID(),
    expense_id,
    version_number: expense.version,
    changed_by_user_id,
    change_type,
    changes: {
      before: before || null,
      after: after || null
    },
    created_at: new Date().toISOString(),
    sync_status: 'pending',
    local_updated_at: new Date().toISOString()
  };

  await db.put('expense_versions', version);
}
```

Update createExpense:
- After creating expense, call recordExpenseVersion with change_type='created', before=null, after=expenseData
- Use transaction to ensure atomic operation

Update updateExpense:
- Load expense before update (capture "before" state)
- Increment version number
- After update, call recordExpenseVersion with change_type='updated', before=oldExpense, after=updatedExpense
- Use transaction

Update deleteExpense:
- Load expense before deletion (capture state)
- After setting is_deleted=true, call recordExpenseVersion with change_type='deleted', before=expenseState, after={is_deleted:true}
- Use transaction

Add restoreExpense function (new):
```typescript
export async function restoreExpense(id: string, userId: string): Promise<void> {
  const db = await initDB();
  const tx = db.transaction(['expenses', 'expense_versions'], 'readwrite');

  const expense = await tx.objectStore('expenses').get(id);
  if (!expense || !expense.is_deleted) return;

  const before = { is_deleted: true, deleted_at: expense.deleted_at };
  expense.is_deleted = false;
  expense.deleted_at = null;
  expense.version += 1;
  expense.updated_at = new Date().toISOString();
  expense.sync_status = 'pending';
  expense.local_updated_at = new Date().toISOString();

  await tx.objectStore('expenses').put(expense);
  await recordExpenseVersion(id, userId, 'restored', before, { is_deleted: false });
  await tx.done;
}
```

Use existing transaction patterns from Phase 8 (createTemplate, deleteTemplate).
Do NOT over-engineer - simple before/after diffs, no complex field-by-field diffing.
  </action>
  <verify>TypeScript compiles without errors, createExpense creates both expense and version record</verify>
  <done>All CRUD operations track changes via recordExpenseVersion, restoreExpense function added, transactions ensure atomicity</done>
</task>

<task type="auto">
  <name>Task 3: Add version history query functions</name>
  <files>lib/db/stores.ts</files>
  <action>
Add query functions for version history:

```typescript
// Get all versions for an expense (sorted by version_number desc)
export async function getExpenseVersions(expense_id: string): Promise<OfflineExpenseVersion[]> {
  const db = await initDB();
  const index = db.transaction('expense_versions').store.index('expense_id');
  const versions = await index.getAll(expense_id);
  return versions.sort((a, b) => b.version_number - a.version_number);
}

// Get specific version by version_number
export async function getExpenseVersion(expense_id: string, version_number: number): Promise<OfflineExpenseVersion | null> {
  const versions = await getExpenseVersions(expense_id);
  return versions.find(v => v.version_number === version_number) || null;
}

// Get all recent changes (for activity feed - limit to last 100)
export async function getRecentExpenseChanges(limit: number = 100): Promise<OfflineExpenseVersion[]> {
  const db = await initDB();
  const allVersions = await db.getAll('expense_versions');
  return allVersions
    .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
    .slice(0, limit);
}
```

Follow existing patterns from getTemplatesByUser, getTemplateById (Phase 8).
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Version query functions added: getExpenseVersions, getExpenseVersion, getRecentExpenseChanges</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (`npx tsc --noEmit`)
- [ ] IndexedDB version 4 with expense_versions store
- [ ] All CRUD operations create version records
- [ ] Version query functions return correct data
- [ ] Transactions ensure atomicity (expense + version always in sync)
</verification>

<success_criteria>

- IndexedDB expense_versions store created with proper indexes
- OfflineExpenseVersion type added with sync tracking
- recordExpenseVersion helper function implemented
- createExpense, updateExpense, deleteExpense all track changes
- restoreExpense function implemented
- Version query functions: getExpenseVersions, getExpenseVersion, getRecentExpenseChanges
- All verification checks pass
- No TypeScript errors introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/09-version-history-and-undo/09-01-SUMMARY.md`:

# Phase 9 Plan 1: Version Tracking Implementation Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 09-02, 09-03, 09-04 (can run in parallel - independent UI components)
</output>
