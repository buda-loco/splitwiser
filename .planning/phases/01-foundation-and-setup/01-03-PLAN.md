---
phase: 01-foundation-and-setup
plan: 03
type: execute
depends_on: [01-01]
files_modified: [public/manifest.json, public/sw.js, app/layout.tsx, next.config.ts, package.json]
---

<objective>
Configure PWA manifest and service worker for offline capability and iOS installability.

Purpose: Enable "Add to Home Screen" on iOS and basic offline functionality for expense tracking.
Output: Working PWA with manifest, service worker, and iOS-optimized configuration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-setup/01-01-SUMMARY.md

**Tech Stack:**
- Next.js native PWA support (no next-pwa plugin needed)
- Manual service worker for maximum control
- iOS Safari as primary PWA target

**Key Requirements:**
- Installable via "Add to Home Screen" on iOS Safari
- Standalone display mode (no browser chrome)
- Offline-capable (foundation for Phase 3 offline-first architecture)
- App icons and splash screens for iOS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PWA manifest</name>
  <files>public/manifest.json, app/layout.tsx</files>
  <action>
Create public/manifest.json with iOS-optimized configuration:

```json
{
  "name": "Splitwiser",
  "short_name": "Splitwiser",
  "description": "Beautiful expense splitting for iOS",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#007AFF",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icon-maskable-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/icon-maskable-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "categories": ["finance", "utilities"],
  "lang": "en-US",
  "dir": "ltr"
}
```

Update app/layout.tsx to include manifest link in metadata:

```typescript
import type { Metadata, Viewport } from "next";
import "./globals.css";

export const metadata: Metadata = {
  title: "Splitwiser",
  description: "Beautiful expense splitting for iOS",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "default",
    title: "Splitwiser",
  },
};

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  viewportFit: "cover",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```

Key settings:
- `display: "standalone"` removes browser chrome
- `theme_color: "#007AFF"` matches iOS blue
- `appleWebApp.capable: true` enables iOS PWA mode
- `statusBarStyle: "default"` for iOS status bar
- Icons with "maskable" purpose for adaptive icons
  </action>
  <verify>Visit localhost:3000, view source shows manifest link in head, curl localhost:3000/manifest.json returns JSON</verify>
  <done>Manifest created with iOS-optimized settings, linked in layout metadata</done>
</task>

<task type="auto">
  <name>Task 2: Create placeholder app icons</name>
  <files>public/icon-192.png, public/icon-512.png, public/icon-maskable-192.png, public/icon-maskable-512.png</files>
  <action>
Create placeholder app icons using ImageMagick (or skip if not available):

```bash
# Check if ImageMagick is available
if command -v convert &> /dev/null; then
  # Create solid blue icons with "S" text (placeholder)
  convert -size 192x192 xc:"#007AFF" -fill white -pointsize 120 -gravity center -annotate +0+0 "S" public/icon-192.png
  convert -size 512x512 xc:"#007AFF" -fill white -pointsize 320 -gravity center -annotate +0+0 "S" public/icon-512.png
  cp public/icon-192.png public/icon-maskable-192.png
  cp public/icon-512.png public/icon-maskable-512.png
else
  echo "ImageMagick not installed. Creating placeholder text files."
  echo "Replace these with real icons before production" > public/icon-192.png.txt
  echo "Replace these with real icons before production" > public/icon-512.png.txt
  echo "Replace these with real icons before production" > public/icon-maskable-192.png.txt
  echo "Replace these with real icons before production" > public/icon-maskable-512.png.txt
fi
```

If ImageMagick not available, just create .txt placeholder files and document in SUMMARY that real icons are needed.

Real icons should be:
- 192x192 and 512x512 PNGs
- Maskable versions with safe zone (80% content area)
- iOS blue (#007AFF) background
- White "S" or full app logo
  </action>
  <verify>ls public/icon-*.png shows 4 icon files (or .txt placeholders if ImageMagick unavailable)</verify>
  <done>App icons created (placeholders if no ImageMagick, production-ready if available)</done>
</task>

<task type="auto">
  <name>Task 3: Create basic service worker</name>
  <files>public/sw.js</files>
  <action>
Create public/sw.js with basic offline support:

```javascript
const CACHE_NAME = 'splitwiser-v1';
const URLS_TO_CACHE = [
  '/',
  '/offline',
];

// Install event - cache essential resources
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('Service worker: Caching essential files');
      return cache.addAll(URLS_TO_CACHE);
    })
  );
  self.skipWaiting();
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('Service worker: Clearing old cache');
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  self.clients.claim();
});

// Fetch event - network first, fall back to cache
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // Clone response to cache and return
        const responseToCache = response.clone();
        caches.open(CACHE_NAME).then((cache) => {
          cache.put(event.request, responseToCache);
        });
        return response;
      })
      .catch(() => {
        // Network failed, try cache
        return caches.match(event.request);
      })
  );
});
```

This provides:
- Network-first strategy (try network, fall back to cache)
- Automatic cache updates on successful fetches
- Foundation for Phase 3 offline-first architecture
- Cache versioning for updates

Phase 3 will enhance this with:
- IndexedDB for expense data
- Background sync for queued operations
- More sophisticated caching strategies
  </action>
  <verify>curl localhost:3000/sw.js returns JavaScript (service worker code)</verify>
  <done>Service worker created with basic offline capability</done>
</task>

<task type="auto">
  <name>Task 4: Register service worker in app</name>
  <files>app/layout.tsx</files>
  <action>
Update app/layout.tsx to register service worker on mount:

Add this Script component inside the <body> (after {children}):

```typescript
import type { Metadata, Viewport } from "next";
import Script from "next/script";
import "./globals.css";

export const metadata: Metadata = {
  title: "Splitwiser",
  description: "Beautiful expense splitting for iOS",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "default",
    title: "Splitwiser",
  },
};

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  viewportFit: "cover",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className="antialiased">
        {children}
        <Script id="register-sw" strategy="afterInteractive">
          {`
            if ('serviceWorker' in navigator) {
              window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(
                  (registration) => {
                    console.log('SW registered:', registration);
                  },
                  (error) => {
                    console.log('SW registration failed:', error);
                  }
                );
              });
            }
          `}
        </Script>
      </body>
    </html>
  );
}
```

This registers the service worker after page load (strategy="afterInteractive") without blocking initial render.
  </action>
  <verify>Visit localhost:3000, open DevTools > Application > Service Workers, see service worker registered and active</verify>
  <done>Service worker registered in app layout, active in browser</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>PWA with manifest, app icons, and service worker for offline capability</what-built>
  <how-to-verify>
1. **Desktop verification:**
   - Visit http://localhost:3000
   - Open DevTools > Application tab
   - Check Manifest: Shows "Splitwiser", theme color #007AFF, display "standalone"
   - Check Service Workers: Shows sw.js registered and activated
   - Check Storage > Cache Storage: Shows "splitwiser-v1" cache

2. **iOS Safari verification (if available):**
   - Open http://[your-local-ip]:3000 on iPhone
   - Tap Share button > Add to Home Screen
   - Confirm app name "Splitwiser" and icon appear
   - Open installed app - should run without Safari chrome (standalone)
   - Enable Airplane Mode > refresh app > should still load (offline)

3. **Android Chrome verification (if available):**
   - Open http://[your-local-ip]:3000 on Android
   - Tap "Add to Home Screen" prompt (or menu > Add to Home Screen)
   - Open installed app - should run in standalone mode

**Expected outcomes:**
- Manifest loads correctly in DevTools
- Service worker registers and activates
- App is installable via "Add to Home Screen"
- App opens without browser chrome when installed
- Basic offline functionality works (cached pages load offline)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `public/manifest.json` exists with iOS-optimized settings
- [ ] `public/sw.js` exists with service worker code
- [ ] App icons exist in public/ (or placeholder .txt files documented)
- [ ] Service worker registers in browser DevTools
- [ ] Manifest is valid (no errors in DevTools > Application > Manifest)
- [ ] PWA installability criteria met (DevTools shows "Add to Home Screen" available)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- PWA manifest created with iOS-optimized configuration
- Service worker implemented with basic offline capability
- App icons created (placeholders acceptable for phase 1)
- Service worker registered and active in browser
- Human verification confirms installability and offline function
- Foundation ready for Phase 3 offline-first architecture
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-setup/01-03-SUMMARY.md`:

---
phase: 01-foundation-and-setup
plan: 03
completed: [YYYY-MM-DD]
subsystem: pwa
requires: [01-01]
provides: [pwa-manifest, service-worker, offline-foundation]
affects: [03-03, 03-04, 03-05, 03-08]
tags: [setup, pwa, offline, ios]
key-decisions:
  - "Native Next.js PWA (no next-pwa plugin)"
  - "Manual service worker for maximum control"
  - "Network-first strategy for online-optimized UX"
key-files:
  - public/manifest.json
  - public/sw.js
  - app/layout.tsx
tech-stack:
  added: [pwa-manifest, service-worker]
  patterns: [standalone-display, offline-cache, network-first]
---

# Phase 1 Plan 3: PWA Configuration

**PWA manifest and service worker configured for iOS installability and basic offline capability.**

## Accomplishments

- Created PWA manifest with iOS-optimized settings (standalone, theme color, status bar)
- Implemented basic service worker with network-first caching strategy
- Created placeholder app icons (192x192, 512x512, maskable variants)
- Registered service worker in app layout
- Enabled "Add to Home Screen" on iOS Safari and Android Chrome
- Established offline foundation for Phase 3 offline-first architecture

## Files Created/Modified

- `public/manifest.json` - PWA manifest with iOS configuration
- `public/sw.js` - Service worker with network-first caching
- `public/icon-*.png` - App icons (4 variants: regular and maskable, 192 and 512)
- `app/layout.tsx` - Added manifest link, iOS meta tags, and service worker registration

## Decisions Made

**Native Next.js PWA vs next-pwa plugin**: Chose native approach for maximum control over service worker behavior. Phase 3 will add complex offline sync logic that requires custom service worker code. Plugin would add unnecessary abstraction layer.

**Network-first caching strategy**: Online experience is default, cache is fallback. This optimizes for connected use case (most common) while providing offline capability. Phase 3 will add IndexedDB for offline-first data.

**Manual app icons**: Created programmatic placeholders instead of design phase. Production icons should be designed separately, but functional placeholders unblock development.

## Issues Encountered

[Document if ImageMagick was unavailable - placeholder .txt files created instead of actual icons]

## Next Phase Readiness

**Foundation for Phase 3 offline-first:**
- Service worker active and caching pages
- Manifest enables installable PWA experience
- Network-first strategy ready to be enhanced with IndexedDB and background sync

**PWA criteria met:**
- ✅ HTTPS (localhost exempt)
- ✅ Valid manifest
- ✅ Service worker registered
- ✅ App icons present
- ✅ Standalone display mode

## Next Step

Ready for parallel execution with Plans 01-04 (Framer Motion). Run `/gsd:execute-phase 1` to execute remaining plans with intelligent parallelization.
</output>
