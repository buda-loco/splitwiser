---
phase: 04-core-expense-creation
plan: 04
type: execute
depends_on: []
files_modified: [components/SplitByPercentage.tsx]
---

<objective>
Implement percentage-based split where each participant gets a custom percentage of the total.

Purpose: Handle uneven splits where percentages are easier than exact amounts (e.g., 60/40 split).
Output: SplitByPercentage component with editable percentages and total validation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-data-model-and-offline-foundation/03-01-SUMMARY.md
@lib/db/types.ts

**Tech stack available:**
- React 19 with hooks
- TypeScript with strict type safety
- Tailwind CSS for iOS-native styling

**Established patterns:**
- Split types from schema: 'percentage' stores value in split_value field
- Decimal(12,2) for amounts
- iOS-native input controls

**Constraining decisions:**
- Phase 3: split_value field stores the percentage (e.g., 60 for 60%)
- Phase 3: amount field stores calculated dollar amount
- PROJECT: Make splitting feel effortless (auto-calculate, clear feedback)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SplitByPercentage component with editable percentages</name>
  <files>components/SplitByPercentage.tsx</files>
  <action>Create component for percentage-based splitting:

**Component structure:**
```tsx
'use client';

import { useState, useMemo } from 'react';
import type { Participant, ExpenseSplit } from '@/lib/db/types';

export function SplitByPercentage({
  amount,
  participants,
  onChange
}: {
  amount: number;
  participants: Participant[];
  onChange: (splits: ExpenseSplit[]) => void;
}) {
  // Track percentage for each participant
  const [percentages, setPercentages] = useState<Record<string, number>>(() => {
    // Initialize with equal percentages
    const equalPercentage = 100 / participants.length;
    return Object.fromEntries(
      participants.map(p => [
        p.user_id || p.participant_id || '',
        Math.floor(equalPercentage * 100) / 100
      ])
    );
  });

  // Calculate splits from percentages
  const splits = useMemo(() => {
    return participants.map(participant => {
      const key = participant.user_id || participant.participant_id || '';
      const percentage = percentages[key] || 0;
      const calculatedAmount = (amount * percentage) / 100;

      return {
        id: crypto.randomUUID(),
        expense_id: '',
        user_id: participant.user_id,
        participant_id: participant.participant_id,
        amount: Math.round(calculatedAmount * 100) / 100, // Round to 2 decimals
        split_type: 'percentage' as const,
        split_value: percentage,
        created_at: new Date().toISOString()
      };
    });
  }, [amount, participants, percentages]);

  // Update parent when splits change
  useMemo(() => {
    onChange(splits);
  }, [splits, onChange]);

  // Calculate totals for validation
  const totalPercentage = Object.values(percentages).reduce((sum, p) => sum + p, 0);
  const totalAmount = splits.reduce((sum, s) => sum + s.amount, 0);
  const percentageValid = Math.abs(totalPercentage - 100) < 0.01;
  const amountValid = Math.abs(totalAmount - amount) < 0.01;

  const handlePercentageChange = (key: string, value: string) => {
    const numValue = parseFloat(value) || 0;
    setPercentages(prev => ({ ...prev, [key]: numValue }));
  };

  // Auto-adjust remaining percentage
  const handleAutoComplete = (key: string) => {
    const remaining = 100 - Object.entries(percentages)
      .filter(([k]) => k !== key)
      .reduce((sum, [, v]) => sum + v, 0);

    setPercentages(prev => ({ ...prev, [key]: Math.max(0, remaining) }));
  };

  return (
    <div className="space-y-3">
      <h3 className="font-medium text-gray-900">Split by Percentage</h3>

      {/* Percentage inputs */}
      <div className="space-y-2">
        {participants.map(participant => {
          const key = participant.user_id || participant.participant_id || '';
          const percentage = percentages[key] || 0;
          const split = splits.find(s =>
            s.user_id === participant.user_id &&
            s.participant_id === participant.participant_id
          );

          return (
            <div key={key} className="flex items-center gap-3">
              <span className="flex-1 text-gray-900">{participant.name}</span>

              <div className="flex items-center gap-2">
                <input
                  type="number"
                  value={percentage}
                  onChange={(e) => handlePercentageChange(key, e.target.value)}
                  onBlur={() => handleAutoComplete(key)}
                  min="0"
                  max="100"
                  step="0.01"
                  className="w-20 px-2 py-1 border border-gray-300 rounded text-right"
                />
                <span className="text-gray-600">%</span>
                <span className="w-20 text-right font-medium text-gray-900">
                  ${split?.amount.toFixed(2) || '0.00'}
                </span>
              </div>
            </div>
          );
        })}
      </div>

      {/* Validation feedback */}
      {!percentageValid && (
        <div className="bg-yellow-50 border border-yellow-300 rounded-lg p-3">
          <p className="text-sm text-yellow-800">
            Percentages total {totalPercentage.toFixed(2)}% (should be 100%)
          </p>
        </div>
      )}

      {!amountValid && percentageValid && (
        <div className="bg-yellow-50 border border-yellow-300 rounded-lg p-3">
          <p className="text-sm text-yellow-800">
            Rounding difference: ${Math.abs(totalAmount - amount).toFixed(2)}
          </p>
        </div>
      )}

      {/* Total */}
      <div className="pt-2 border-t border-gray-300">
        <div className="flex justify-between">
          <span className="font-semibold">Total</span>
          <div className="flex gap-4">
            <span className={percentageValid ? 'text-green-600' : 'text-red-600'}>
              {totalPercentage.toFixed(2)}%
            </span>
            <span className="font-semibold">${totalAmount.toFixed(2)}</span>
          </div>
        </div>
      </div>
    </div>
  );
}
```

**Features:**
- Editable percentage inputs per participant
- Real-time amount calculation
- Auto-complete feature (onBlur sets remaining %)
- Validation showing if totals don't match 100%
- Shows both percentage and dollar amount
- iOS-native number inputs

**UX patterns:**
- Initialize with equal percentages
- Type percentage, auto-calculate amount
- Blur on input auto-fills to reach 100%
- Visual feedback when totals invalid

**Avoid:**
- DO NOT require percentages to be integers (allow decimals)
- DO NOT block submission if totals off by < 1 cent (rounding tolerance)
- DO NOT auto-adjust on every keystroke (only on blur)
- DO NOT allow negative percentages or > 100%</action>
  <verify>TypeScript compiles, component renders percentage inputs, amounts calculated correctly, validation shows when percentages != 100%, auto-complete works on blur</verify>
  <done>SplitByPercentage component created with editable percentages, real-time calculation, auto-complete, validation feedback</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compiles without errors (npx tsc --noEmit)
- [ ] Component renders percentage input for each participant
- [ ] Amounts calculated correctly from percentages
- [ ] Validation shows when total != 100%
- [ ] Auto-complete fills remaining percentage on blur
- [ ] iOS-native styling matches established patterns
</verification>

<success_criteria>
- SplitByPercentage component with editable percentage inputs
- Real-time amount calculation as percentages change
- Auto-complete feature for reaching 100%
- Validation feedback for invalid totals
- Integrates with ExpenseSplit schema type
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-expense-creation/04-04-SUMMARY.md`:

# Phase 4 Plan 4: Split by Percentage Summary

**Custom percentage splits with validation and auto-complete**

## Accomplishments

- Created SplitByPercentage component with editable inputs
- Implemented real-time amount calculation from percentages
- Added auto-complete feature to reach 100% on blur
- Built validation feedback for invalid totals
- Handled percentage-to-amount conversion with proper rounding

## Files Created/Modified

- `components/SplitByPercentage.tsx` - Percentage split component

## Decisions Made

[Document auto-complete behavior, validation tolerance, rounding approach]

## Issues Encountered

[Any issues with percentage calculation, rounding, or "None"]

## Next Step

Independent of 04-03 and 04-05 (equal/shares splits)
</output>
